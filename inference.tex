\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm, array, stmaryrd}
\usepackage{wasysym}
\usepackage{booktabs}
\usepackage{todonotes}
\usepackage{float}
\usepackage{scalerel}
%% \usepackage[notext,not1,nomath]{stix}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{soul}

\title{Notes on Control Plane Inference}
\author{Eric Campbell}


% semantics
\newcommand{\pkt}{\mathit{pkt}}
\newcommand{\error}{\mathsf{error}}
\newcommand{\denote}[1]{\left\llbracket#1\right\rrbracket}
\newcommand{\edenote}[1]{\mathcal{E}\denote{#1}}

%booleans
\newcommand{\TRUE}{\mathsf{tt}}
\newcommand{\FALSE}{\mathsf{ff}}

%% bitvectors
\newcommand{\binop}{\mathbin{\oplus}}
\newcommand{\unop}{\mathop{\text{\pointer}}}

% sets
\newcommand{\Value}{\mathsf{Value}}
\newcommand{\BVExpr}{\mathsf{BVExpr}}
\newcommand{\BExpr}{\mathsf{BExpr}}
\newcommand{\Cmd}{\mathsf{Cmd}}
\newcommand{\Action}{\mathsf{Action}}
\newcommand{\Instr}{\mathsf{Instr}}
\newcommand{\Prog}{\mathsf{Prog}}
\newcommand{\GCL}{\mathsf{GCL}}
\newcommand{\Pkt}{\mathsf{Pkt}}
\newcommand{\Model}{\mathsf{Model}}
\newcommand{\Hdr}{\mathsf{Hdr}}
\newcommand{\Field}{\mathsf{Field}}
\newcommand{\Table}{\mathsf{Table}}
\newcommand{\Row}{\mathsf{Row}}
\newcommand{\List}{\mathsf{List}}
\newcommand{\Var}{\mathsf{Var}}
\newcommand{\SymbRow}{\mathsf{SymbRow}}
\newcommand{\Ghost}{\mathsf{Ghost}}
\newcommand{\State}{\mathsf{State}}
\newcommand{\Kind}{\mathsf{Kind}}

% record fields
\newcommand{\matches}{\mathsf{matches}}
\newcommand{\action}{\mathsf{action}}
\newcommand{\actions}{\mathsf{actions}}
\newcommand{\keys}{\mathsf{keys}}
\newcommand{\data}{\mathsf{data}}
\newcommand{\params}{\mathsf{params}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\reach}{\mathit{\mathit{reach}}}
\newcommand{\hit}{\mathit{hit}}
\newcommand{\reads}{\mathit{reads}}
\newcommand{\hitAction}{\mathsf{hitAction}}
\newcommand{\miss}{\mathsf{miss}}

% commands
\newcommand{\assert}{\mathop{\mathsf{ast}}}
\newcommand{\assume}{\mathop{\mathsf{asm}}}
\newcommand{\apply}{\mathsf{apply}}
\newcommand{\choiceop}{\rotatebox[origin=c]{90}{$\sqsubset\!\!\!\sqsupset$}}
\newcommand{\choice}{\mathbin{\choiceop}}
\DeclareMathOperator*{\bigchoice}{\scalerel*{\choiceop}{\sum}}
\newcommand{\havoc}[1]{\mathop{\mathsf{hvc}}#1}
\newcommand{\SKIP}{\mathsf{skip}}

% matchkinds
\newcommand{\exact}{\ensuremath{\mathsf{exact}}}
\newcommand{\ternary}{\ensuremath{\mathsf{ternary}}}
\newcommand{\lpm}{\ensuremath{\mathsf{lpm}}}

% math
\newcommand{\argmin}{\mathop{\textrm{argmin}}}
\newcommand{\WP}{\textit{wp}}
\newcommand{\satisfy}[3]{({#1,#3}) \models_{#2}}
\newcommand{\notsatisfy}[3]{({#1,#3})\not\models_{#2}}
\newcommand{\nondet}{\mathsf{nondet}}
\newcommand{\ghostly}{\mathsf{ghostly}}
\newcommand{\state}[1]{\llparenthesis#1\rrparenthesis}
\newcommand{\instr}{[?]}
\newcommand{\ginstr}{[\mathghost]}
\newcommand{\qe}{\textsc{Qe}}
\newcommand{\dom}{\textrm{dom}}
\newcommand{\fvs}{\textrm{fvs}}
\newcommand{\efvs}{\textrm{efvs}}
\newcommand{\bfvs}{\textrm{bfvs}}


%% operators
\newcommand{\bvand}{\mathop{\texttt{\&}}}
\newcommand{\match}{\mathrel{\texttt{{=}\raisebox{-2.5px}{\textasciitilde}}}}
\newcommand{\matchrow}{\mathsf{matchrow}}

% defined functions
\newcommand{\tables}{\mathop{\mathsf{tables}}}

% Theorems
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem{remark}{Remark}


\begin{document}

\maketitle

\section{Preliminaries}

\subsection{Syntax}

\begin{figure}[htp]
  \[\begin{array}{lclll}
    \multicolumn{3}{l}{\Value} \\
    v & ::= & [n]_w  & \textit{Bitvector Literal} \\
    \multicolumn{3}{l}{\SymbRow} \\
    \rho & ::= & \left\{
    \begin{array}{l}
      \matches = \List[x];\\
      \action = x;\\
      \data = \List[x]
    \end{array}\right\} & \textit{Symbolic Row} \\
    \multicolumn{3}{l}{\BVExpr} \\
    e & ::= & v & \textit{Value} \\
      & \mid & x & \textit{Variable}\\
      & \mid & e \binop e & \textit{Arbitrary Binary Operation}\\
    & \mid & \unop e & \textit{Arbitrary Unary Operation} \\
    \multicolumn{3}{l}{\Kind} \\
    t & ::= & \exact  & \textit{Exact Match}\\
    & \mid & \ternary & \textit{Ternary Match} \\
    & \mid & \lpm & \textit{Longest Prefix Match} \\
    \multicolumn{3}{l}{\Table} \\
    t & ::= & \left\{\begin{array}{l}
    t.\id = v; \\
    t.\keys = \List[h.f : \kappa]; \\
    t.\actions = \List[\lambda \vec x.\,a]\\
    \end{array}\right\} & \textit{Table}\\
    \multicolumn{3}{l}{\BExpr} \\
    b & ::= & \FALSE  & \textit{Absurdity}\\
      & \mid & b \Rightarrow b & \textit{Implication}\\
    & \mid & e = e & \textit{Bitvector Equality}\\
    %% & \mid & \rho \in t & \textit{Table membership}\\
    %% & \mid & \forall \rho.~b & \textit{Row Universality}\\
    \multicolumn{4}{l}{c \in \Cmd, a \in \Action, g \in \GCL, p \in \Prog, \iota \in \Instr } \\
    c & ::=  & h.f := e & \textit{Assignment} \\
      & \mid & \havoc \rho & \textit{Row Havoc} \\
      & \mid & \assert b & \textit{Assertion}\\
      & \mid & \assume b & \textit{Assumption} \\
      & \mid & t.\apply() & \textit{Table Application} \\
      & \mid & c;c & \textit{Sequential Composition} \\
      & \mid & c \choice c & \textit{Nondeterministic Choice} \\
      %% & \mid & \{c\} & \textit{Scope} & (g,p,\iota)\\
    \multicolumn{3}{l}{
      \begin{array}{ll}
        x \in \Var & h \in \Hdr\\
        n,w,i \in \mathbb{N} & f \in \Field
    \end{array}} & \textit{Sets }\\
  \end{array}
\]
\caption{Grammar of Commands $c \in \Cmd$.}
\label{fig:grammar}
\end{figure}

The following sections describe aspects of the grammar shown in Figure~\ref{fig:grammar}.


\paragraph{Variables}
Dataplane programs use variables $x \in \Var$ to represent packet state.

\paragraph{Values}
Values $v \in \Value$ are bitvector literals, written $[n]_w$, where $n$
is a natural value and $w$ is the width. We say that $[n]_w = [m]_l$ is
undefined if $w \neq l$, and otherwise is true iff $n \equiv m \mod 2^w$.


\paragraph{Packets}
Our dataplane programs will reason about structured representations of packets,
that is, they will be transformations on sets of packet headers. We define
Packets to be functions from variables to values, that is $\Pkt = \Value^\Var$.
Use the syntax $\pkt\{x \mapsto v\}$ to represent the packet that is equivalent
to $\pkt$ on all variables fields except $x$, which maps to $v$. Use $\pkt(x)$
to look up the value of $x$ in packet $\pkt$.

\paragraph{Tables}
A table $t \in \Table$ is a record with a few fields described below:
\begin{enumerate}[align=left]
  \item[($t.\id$)] A table's unique identifier. A well-formed program can only
    have one occurence of each table identifier.
  \item[($t.\keys$)] A list of header field accesses indicating the match keys and their match kind.
  \item[($t.\actions$)] A list of actions that can be executed. An action is a lambda
    expression $\lambda \vec x. c$ where the variables $x$ are in scope for the
    commands $c$, which $c$ are straight-line code only (see below).
\end{enumerate}
For now we assume that the default action is always specified by the controller.
That is, programs never `miss' in tables. See the paragraph on state below. We use $|l|$ to indicate the number of
elements in a list or vector $l$ such as $t.\keys$ or $t.\actions$.

\paragraph{Match Kind}
There are three match kinds, \exact, \ternary, and \lpm. Exact matches (\exact)
indicate that the bits in the key must be the same as the match bits. Ternary
matches (\ternary) specify a match and a mask and the key must be equivalent up
to masking. Longest prefix matches (\lpm) specify a match and a length
$l$, the first $l$ bits of the key must be equivalent to the match.


\paragraph{Symbolic Table Rows}
A symbolic table row $\rho_t \in \SymbRow \subseteq \Var$ represents a symbolic row for table
$t$. These rows are represented in our programs as simple variables. Like
tables, rows are also ``records'' with the following fields \todo{well formedness constraint?}
\begin{enumerate}[align=left]
  \item[($\rho_t.\matches$)] A list variable of length representing the possible match keys.
  \item[($\rho_t.\action$)] A variable representing the action choice
  \item[($\rho_t.\data$)] A list variable representing the possible action data
  \item[($\rho_t.\id$)] A single variable representing the row's index.
\end{enumerate}

To represent the $i$th match variable in $\rho$, use standard list
access notation: $\rho.\matches[i]$.

Note that symbolic table rows are only meant to be used in the instrumentation
stage and not by a programmer.

For a set of tables $T \subseteq \Table$, we absue set-builder notation to write the shorthand
$\{\rho_t.*| t \in T \}$ to indicate the set $\{\rho_t.f | t \in T, f \in
\{\action, \id, \matches[0], \ldots, \matches[n_t], \data[0], ldots, \data[m_t]
\}\}$ where $n_t = |t.\keys|$ and $m_t = \max\{|\vec x| \mid\lambda \vec x. c
\in t.\actions\}$


\paragraph{Ghost Variables}
A ghost varaible $\gamma_t \in \Ghost \subseteq \Var$ represents some ghost
state for table $t$. These ghost variables are represented as simple variables
in our program. They are ``records'' with the following fields
\begin{enumerate}[align=left]
\item[($\gamma_t.\miss$)] Equal to $[1]_1$ if the table packet misses in the table, and $[0]_1$ otherwise.
\item[$(\gamma_t.\keys)$] A list variable that captures the values of the keys at table-application time.
\end{enumerate}

For a set of tables $T \subseteq \Table$, we absue set-builder notation to write
the shorthand $\{\gamma_t.*| t \in T \}$ to indicate the set $\{\gamma_t.f | t \in
T, f \in \{\miss, \keys[0], \ldots, \keys[n_t]\}\}$ where $n_t = |t.\keys|$.

\paragraph{Bitvector Expressions}
Bitvector expressions $e \in \BVExpr$ can be values $v$, header accesses $h.f$,
symbolic row variables, variables $x$, or any
(currently unspecified) binary or unary bitvector operation.

\paragraph{Boolean Expressions}
Boolean expressions $b \in \BExpr$ can be $\FALSE$, implication ($b_1
\Rightarrow b_2$), equality of bitvector expressions ($e_1 = e_2$ for two
bitvector expressions $e_1$ and $e_2$), or universal quantification $\forall
\rho \in t. b$, where $\rho$ is a symbolic row in table $t$. Note that universal
quantification is meant to only be used by the instrumentation mechanism and not
a programmer.

We can represent other standard boolean operators by using standard encodings:
\[\begin{array}{l}
  \TRUE \triangleq \FALSE \Rightarrow \FALSE \\
  \neg b \triangleq b \Rightarrow \FALSE \\
  b_1 \vee b_2 \triangleq \neg b_1 \Rightarrow b_2 \\
  b_1 \wedge b_2 \triangleq \neg(\neg b_1 \vee \neg b_2) \\
  \vec e = \vec e' \triangleq \bigwedge_i e_i = e'_i
\end{array}\]

\paragraph{Commands}
Data plane programs $c \in \mathsf{Cmd}$ can be assignments ($h.f := e$), havoc
statements ($\havoc x$), assumptions ($\assume b$), assertions ($\assert b$),
table application ($t.\apply()$), sequential composition ($c_1;c_2$ for two
commands $c_1$ and $c_2$), and nondeterministic choice ($c_1 \choice c_2$ for
two commands $c_1$ and $c_2$). Note that table application, havoc, and
nondeterministic choice are is prohibited in action bodies.

\begin{definition}
  \label{def:well-formed-command}
   A command $c \in \Cmd$ is \emph{well-formed} if tables only occur once in the
   program and each has a unique $t.\id$.
\end{definition}

We define $\SKIP$ as syntactic sugar for $\assume \TRUE$. We also lift havoc to
sets of variables $\havoc \{x_1,\ldots,x_n\} = \SKIP; \havoc{x_1}; \cdots; \havoc{x_n}$.


It is sensible to use sets here (rather than lists), because havocs commute:

\begin{lemma}[Havocs Commute]
  For any two variables $\{x_1,x_2\} \subseteq \Var$,
  \[\forall \sigma.\forall \pkt. \denote{\havoc{x_1};\havoc{x_2}}^\sigma\pkt = \denote{\havoc{x_2};\havoc{x_2}}^\sigma\pkt \]
\end{lemma}

\begin{proof}
  Let $x_1, x_2,\sigma,\pkt$ be given.
  Compute as follows:
  \[
  \begin{array}{ll}
    \denote{\havoc{x_1};\havoc{x_2}}^\sigma\pkt\\
    = {\denote{\havoc{x_2}}^\sigma}^\dagger\left(\denote{\havoc{x_1}}\right)^\sigma\pkt
    & \\
    = {\denote{\havoc{x_2}}^\sigma}^\dagger\{\pkt\{x_1 \mapsto v_1\} \mid v_1 \in \Value\}
    & \\
    = \{\pkt\{x_1 \mapsto v_1\}\{x_2 \mapsto v_2\} \mid v_1,v_2 \in \Value\}
    & \\
    = \{\pkt\{x_2 \mapsto v_2\}\{x_1 \mapsto v_1\} \mid v_1,v_2 \in \Value\}
    & \\
    = {\denote{\havoc{x_1}}^\sigma}^\dagger\{\pkt\{x_2 \mapsto v_2\} \mid v_2 \in \Value\}
    & \\
    = {\denote{\havoc{x_1}}^\sigma}^\dagger\left(\denote{\havoc{x_2}}^\sigma\pkt\right)\}
    & \\
    = \denote{\havoc{x_2};\havoc{x_2}}^\sigma\pkt
  \end{array}
  \]
\end{proof}

Define $\tables(c) \subset \Table$ to be the set of all tables that occur in $c$.

\subsection{Semantics}

First we describe the semantic objects packet and state before giving semantics
to bitvector expressions, boolean expressions, and commands.


\paragraph{State}
On-switch state is represented by a mapping from tables identifiers $t.\id$ to
lists of rows $[r_1,\ldots,r_n] \in \Row(t)^*$. I.e. the set of states $\State =
\Value \to \Row^*$

A similar to a symbolic row $\rho$, a concrete row $r$ comprises a list of match
values $r.\matches$, an action identifier $r.\action$, a list of action data
$r.\data$, and an index $r.\id$. A concrete row $r$ is in the set $\Row(t)$ if
it is well-formed for a table $t$ iff the following conditions hold:
\begin{enumerate}
\item $|r.\matches| = |t.\keys|$
\item $r.\action < |t.\actions|$
\item $|r.\data| = |\vec x|$ where $\lambda \vec x. c = t.\actions[r.\action]$
\end{enumerate}

A state map $\sigma : \Value \to \Row^*$ is well-formed for a command $c$ iff
the following conditions hold:
\begin{enumerate}[align=left]
\item[(\textsc{WellFormedRows})] For every $t\in \tables(c)$, every row in $\sigma(t.\id)$ is well-formed.
\item[(\textsc{SelfRef})] For every $t \in tables(c)$, such that $[r_1,\ldots,
  r_n] = \sigma(t.\id)$, $r_i.\id = i$ for all $1 \leq i \leq n$.
\end{enumerate}

Because of the well-formedness assumption about commands, overload $\sigma(t)
\triangleq \sigma(t.\id)$.

\paragraph{Expressions}
The semantics of expressions is shown in Figure~\label{fig:sem-expr}. Note that
here we implicitly use the strict semantics for definedness, that is, operators
only succeed when all of their arguments are defined, otherwise it returns
undefined.

\begin{figure}[H]
  \[\begin{array}{l>{\triangleq}cl}
  \multicolumn{3}{l}{\edenote{e} : \Pkt \to \Value }\\
    \edenote{v}\pkt &&
    v \\
    \edenote{h.f}\pkt &&
    pkt(h.f)\\
    %% \edenote{\rho.\matches[i]}\pkt &&
    %% \mu(\rho).\matches[i] \\
    %% \edenote{\rho.\action}\pkt &&
    %% \mu(\rho).\action \\
    %% \edenote{\rho.\data[i]} &&
    %% \mu(\rho).\data[i]\\
    \edenote{e_1 \binop e_2}\pkt&&
    \edenote{e_1}\pkt \binop
    \edenote{e_2}\pkt \\
    \edenote{\unop e}\pkt &&
    \unop \left(\edenote{e}\pkt\right)
  \end{array}
  \]
  \caption{Semantics of Expressions}
  \label{fig:sem-expr}
\end{figure}

\paragraph{Boolean Satisfaction}
The satisfaction relation $\pkt \models b$ is defined in
Figure~\ref{fig:bool-satis}. It is completely standard.

\begin{figure}
  \[
  \begin{array}{l >{\iff}c l}
    \pkt \models \FALSE
    && \mathit{never}\\
    \pkt \models b_1 \Rightarrow b_2
    && \pkt \not\models b_1~\mathit{or}~\pkt \models b_2\\
    \pkt \models e_1 = e_2
    && \edenote{e_1}\pkt = \edenote{e_2}\pkt\\

  \end{array}
  \]
  \caption{The satisfaction relation}
  \label{fig:bool-satis}
\end{figure}


\paragraph{Command Evaluation}
Commands are evaluated similar to Avenir in Figure~\ref{fig:com-sem}. The
notable differences are the inclusion of assertions, the nondeterminism
operators, support for inexact matches, and a cleaner representation of table
application. The denotation function $\denote{-}$ is parameterized on a
$\sigma$, it is used in the definition of $t.\apply()$. If no $\sigma$ is
provided, the behavior of $t.\apply()$ is undefined.

In evaluating tables, we must condition on and evaluate matches. To do this, we
define an operator $t.\matchrow : \Row \to \BExpr$ which checks that the lists of
matches and keys are equivalent up to the corresponding match type.

First, define an auxiliary binary operator $(\match) : (\BVExpr \cup \BVExpr^2 \cup \BVExpr/\BVExpr) \to (\BVExpr \times \Kind) \to \BExpr$ that is $\TRUE$ iff the arguments are equivalent up
to the match kind $\kappa$. Formally we define this as follows:

\[
\begin{array}{r<{\!\!\!} l >{\triangleq}cl}
  e \match e' :& \exact && e = e' \\
  (e_v,e_m) \match e' :& \ternary && e_v \bvand e_m = e' \bvand e_m \\
  e/l \match  e' :& \lpm && e \bvand 1^l0^{|e| - l} = e' \bvand 1^l0^{|e| - l} \\
\end{array}
\]

Now we can define $t.\matchrow(r)$ as follows
\[t.\matchrow(r) \triangleq
   \bigwedge_{i = 0}^n r.\matches[i] \match t.\keys[i]
\]


\begin{figure}[htp]
  \[\begin{array}{r >{\triangleq}cl}
  \multicolumn{3}{l}{\denote{c}^\sigma : \Pkt \to \mathcal{P}(\Pkt)_\error }\\
  \denote{x := e}^\sigma\pkt && \{\pkt\{x \mapsto \edenote{e}\pkt\}\} \\
  \denote{\havoc x}^\sigma\pkt && \{ \pkt\{x \mapsto v\} \mid v \in \Value \} \\
    \denote{\assume b}^\sigma\pkt &&
    \begin{cases}
      \{\pkt\} & \pkt \models b \\
      \{\} & \textit{otherwis
e} \\
    \end{cases}\\
    \denote{\assert b}^\sigma\pkt &&
    \begin{cases}
      \{\pkt\} & \pkt \models b \\
      \error & \textit{otherwise}
    \end{cases} \\
    %% \denote{\havoc \rho}^\sigma\,\mu\,\pkt &&
    %% \{(\mu\{\rho \mapsto r\}, \pkt) \mid r \in \Row\} \\
    \denote{c_1;c_2}^\sigma\pkt&&
    %% \bigcup_{\pkt' \in \denote{c_1}^\sigma\pkt}\denote{c_2}^\sigma\pkt' \\
    {\denote{c_2}^\sigma}^\dagger\left(\denote{c_1}^\sigma\pkt\right)\\
    \denote{c_1 \choice c_2}^\sigma\pkt &&
    \denote{c_1}^\sigma\pkt \cup \denote{c_2}^\sigma\pkt \\
    %% \denote{\{c\}}^\sigma\,\mu\,\pkt &&
    %% \{(\mu,\pkt') \mid (\mu',\pkt') \in \denote{c}^\sigma\,\mu\,\pkt \}\\
    \denote{t.\apply()}^\sigma\,\pkt &&
    \begin{cases}
      \denote{c[\vec d/\vec x]}^\sigma\pkt,
      & \text{exists}~r = \argmin_i\{\pkt \models b_i\} \\
      & \text{where}~\lambda \vec x.~c = r.\action, \vec d = r.\data \\
      & \text{where}~b_i = t.\matchrow(\sigma(t.\id)[i]) \\
      \{\pkt\}, & \textit{if no such } r \textit{ exists}
    \end{cases}
  \end{array}\]
  \caption{Semantics of Commands. The dagger operator $(\cdot^\dagger) : (\Pkt \to
    \mathcal{P}(\Pkt)_\error) \to \mathcal{P}(\Pkt)_\error \to
    \mathcal{P}(\Pkt)_\error$ lifts a function that accepts packets to one that
    accepts elements of to the pointed powerset.}
  \label{fig:com-sem}
\end{figure}

\subsection{Definitions}

\begin{definition}[Free Variables]
  The free variables of a command $c$, written $\fvs(c) \subseteq \Var$, is the
  set of variables that occur at any point in $c$ (i.e. as the lhs of an
  assignment, in a boolean expression, a bitvector expression, as a key in a
  table.) The only bound variables are the action data in tables. Formally:
  \[\begin{array}{l >{\triangleq}cl}
  \efvs :: \BVExpr \to \mathcal{P}(\Var) \\
  \efvs(v) && \{\} \\
  \efvs(x) && \{x\}\\
  \efvs(e_1 \binop e_2) && \efvs(e_1) \cup \efvs(e_2)\\
  \efvs(\unop e) && \efvs(unop) \\[1em]
  \bfvs :: \BExpr \to \mathcal{P}(\Var) \\
  \bfvs(\FALSE) && \{\}\\
  \bfvs(b_1 \Rightarrow b_2) && \bfvs(b_1) \cup \bfvs(b_2)\\
  \bfvs(e_1 = e_2) && \efvs(e_1) = \efvs(e_2) \\[1em]
  \fvs :: \Cmd \to \mathcal{P}(\Var) \\
  \fvs(x := e) && \{x\} \cup \fvs(e)\\
  \fvs(\havoc x) && \{x\}\\
  \fvs(\assume b) && \fvs(b)\\
  \fvs(\assert b) && \fvs(b) \\
  \fvs(c_1;c_2) && \fvs(c_1) \cup \fvs(c_1) \\
  \fvs(c_1 \choice c_2) && \fvs(c_1) \cup \fvs(c_2) \\
  \fvs(t.\apply()) &&
  t.\keys \cup \bigcup_{\lambda \vec x. c \in t.\actions} (\fvs(c) \setminus \{x_1,\ldots, x_n\})
  \end{array}\]
\end{definition}



\begin{definition}[Projections]
  For a set of variables $S \subseteq \Var$, and a packet $\pkt$, write
  $\pkt|_S$ to be projection of $\pkt$ onto $S$. \todo{I guess this means
    packets are partial functions?} Formally,
  \[\pkt|_S \triangleq \{x \mapsto \pkt(x) \mid x \in S\}.\]
  Two packets $\pkt$, $\pkt'$ are equivalent up to $S \subseteq \Var$, written
  $\pkt =_S \pkt'$, iff $\pkt|_S = \pkt'|_s$. A set of packets $P$ is a subset
  of $P'$ up to $S$, written $P \subseteq_S P'$ iff for every packet $\pkt \in
  P$, there exists $\pkt' \in P'$ such that $\pkt =_S \pkt'$. Two sets of
  packets $P$ and $P'$ are $S$-equivalent, written $P =_S P'$ iff $P \subseteq_S
  P'$ and $P \subseteq_S P'$. A set $P \subseteq \Pkt$ is a $V$-equivalence
  class if $\forall \pkt_1, \pkt_2 \in P$, $\pkt_1 =_V \pkt_2$.
\end{definition}


\begin{lemma}[Projection Union-Distributivity]
  \label{lem:proj-union-set}
  For all $P,Q \subseteq \Pkt$, $V \subseteq \Var$,
  $(P\cup Q)|_V = P|_V \cup Q|_V$
\end{lemma}

\begin{proof}
  Let $P,Q \subseteq \Pkt$ and $V \subseteq \Var$ be given. Compute:

  \[\begin{array}{ll}
  (P\cup Q)|_V\\
  = \{\pkt|_V \mid \pkt \in P\cup Q\}\\
  = \{\pkt|_V \mid \pkt \in P\}\cup \{\pkt|_V \mid \pkt \in Q\}\\
  = P|_V \cup Q|_V
  \end{array}\]
\end{proof}

\begin{lemma}[Projection Idempotence]
  \label{lem:proj-idem}
  For all $\pkt \in \Pkt$, $V \subseteq \Var$,
  $(\pkt|_V)|_V = \pkt|_V$
\end{lemma}

\begin{proof}
  Let $\pkt \in \Pkt$ and $V \subseteq \Var$ be given.
  \[\begin{array}{ll}
    (\pkt|_V)|_V \\
    = \{x \mapsto (\pkt|_V)(x) \mid x \in V\} & \text{by definition}\\
    = \{x \mapsto (\{y \mapsto \pkt(y) \mid y \in V\})(x) \mid x \in V\} & \text{by definition}\\
    = \{x \mapsto \pkt(x) \mid x \in V\} & \beta\text{-reduction}\\
    = \pkt|_V & \text{by definition}
  \end{array}\]
\end{proof}


\begin{lemma}[Projection Idempotence for Sets]
  \label{lem:proj-idem-set}
  For all $P \subseteq \Pkt$, $V \subseteq \Var$,
  $(P|_V)|_V = P|_V$
\end{lemma}

\begin{proof}
  Let $P \subseteq \Pkt$ and $V \subseteq \Var$ be given. Compute:
  \[\begin{array}{ll}
  (P|_V)|_V \\
  = \{\pkt|_V \mid \pkt \in P|_V\}
  & \text{by definition of } (\cdot)|_V : \mathcal{P}(\Pkt) \to \mathcal{P}(\Pkt) \\
  = \{\pkt|_V \mid \pkt \in \{\pkt'|_V \mid \pkt'\in P\}\}
  & \text{by definition of } (\cdot)|_V : \mathcal{P}(\Pkt) \to \mathcal{P}(\Pkt) \\
  = \{(\pkt|_V)|_V \mid \pkt \in P \}
  & \text{by set theory} \\
  = \{\pkt|_V \mid \pkt \in P\} & \text{by Lemma~\ref{lem:proj-idem}} \\
  = P|_V & \text{by definition of } (\cdot)|_V : \mathcal{P}(\Pkt) \to \mathcal{P}(\Pkt)
  \end{array}\]
\end{proof}

\begin{lemma}[Subset Packet Projection]
  \label{lem:subset-pkt-proj}
 Let $\pkt_1,\pkt_2 \in \Pkt$ and $U \subseteq V \subseteq \Var$,
  If $\pkt_1 =_V \pkt_2$, then $\pkt_1 =_U \pkt_2$.
\end{lemma}
\begin{proof}
  Let $\pkt_1$,$\pkt_2$, $U$, $V$ be given as above. Assume $\pkt_1 =_V \pkt_2$.
  Let $x \in U$, show that $\pkt_1(x) = \pkt_2(x)$. Since $U \subseteq V$, $x
  \in V$, so by assumption $\pkt_1(x) = \pkt_2(x)$.
\end{proof}

\begin{lemma}[Subset Projection Subset]
  \label{lem:subset-proj-subset}
  For $P,Q \subseteq \Pkt$ and $U \subseteq V \subseteq \Var$,
  If $P \subseteq_V Q$, then $P \subseteq_U Q$.
\end{lemma}

\begin{proof}
  Let $P$,$Q$,$U$,$V$ be given as above. Assume $P \subseteq_V Q$. Show $P
  \subseteq_U Q$. Let $\pkt \in P$. Since $P \subseteq_V Q$, we know that there
  is some $\pkt' \in Q$ such that $\pkt =_V \pkt'$. By Lemma~\ref{lem:subset-pkt-proj},
  $\pkt =_U \pkt'$. The result follows.
\end{proof}


\begin{corollary}[Subset Implies Projected Subset]
  \label{lem:subset-proj}
  For $P,Q \subseteq \Pkt$, and $ V \subseteq \Var$,
  If $P \subseteq Q$ then $P \subseteq_V Q$.
\end{corollary}

\begin{lemma}[Subset Projection Equality]
  \label{lem:subset-proj-equal}
  For $P,Q \subseteq \Pkt$ and $U \subseteq V \subseteq \Var$,
  If $P =_V Q$, then $P =_U Q$.
\end{lemma}

\begin{proof}
  Let $P$,$Q$,$U$,$V$ be given as above. Assume $P =_V Q$. Show $P =_U Q$. Let
  $\pkt \in P$. Since $P =_V Q$, we know that $P \subseteq_V Q$ and $Q
  \subseteq_V P$. By Lemma~\ref{lem:subset-proj-subset},$P \subseteq_U Q$ and $Q
  \subseteq_U P$. Conclude $P =_U Q$.
\end{proof}

\begin{corollary}[Equality Implies Projected Equality]
  \label{lem:equal-proj}
  For $P,Q \subseteq \Pkt$, and $ V \subseteq \Var$, If $P = Q$ then $P =_V Q$.
\end{corollary}



\begin{lemma}[Union Packet Projection]
  \label{lem:union-pkt-proj}
  For $\pkt_1,\pkt_2 \in \Pkt$, and $U, V \subseteq \Pkt$, if $\pkt_1 =_U
  \pkt_2$ and $\pkt_1 =_V \pkt_2$, then $\pkt_1 =_{U \cup V} \pkt_2$.
\end{lemma}

\begin{proof}
  Let $\pkt_1$, $\pkt_2$, $U$, $V$ be given as above. Assume $\pkt_1 =_U \pkt_2$
  and $\pkt_1 =_V \pkt_2$. Let $x \in U \cup V$. There are two cases. If $x \in
  U$, the assumption $\pkt_1 =_U \pkt_2 $ gives $\pkt_1(x) = \pkt_2(x)$.
  Conversely if $x \in V$, the assumption $\pkt_1 =_V \pkt_2$ gives $\pkt_1(x) =
  \pkt_2(x)$. Conclude $\pkt_1 =_{U \cup V} \pkt_2$.
\end{proof}

\begin{lemma}[Expression Projection]
  \label{lem:proj-expr}
  For every set of variables $V \subseteq \Var$, packet $\pkt \in \Pkt$ and
  expression $e \in \BVExpr$, such that $\efvs(e) \subseteq V$, $\edenote{e}\pkt =
  \edenote{e}(\pkt|_V)$.
\end{lemma}
\begin{proof}
  Let $V \subseteq \Var$ be given.
  Proceed by induction on $e$, leaving $\pkt$ arbitrary.
  \begin{enumerate}[align=left]
  \item[($e = v$)] Let $\pkt$ be given. $\edenote{v}\pkt = v = \edenote{v}{\pkt|_V}$
  \item[($e = x$)] Let $\pkt$ be given. Note that $\efvs(x) = \{x\} \subseteq V$. Compute:
    \[\begin{array}{ll}
    \edenote{x}(\pkt|_V) \\
    = (\pkt|_V)(x)
    & \text{by definition of }\edenote\cdot\\
    = \{y \mapsto \pkt(y) \mid y \in V\}(x)
    & \text{by definition of }(\cdot)|_V : \Pkt \to \Pkt\\
    = \pkt(x) & \text{since } x \in V
    \end{array}
    \]
  \item[($e = e_1 \binop e_2$)] Let $\pkt$ be given. Compute:
    \[\begin{array}{ll}
    \edenote{e_1 \binop e_2}\pkt \\
    = \edenote{e_1}\pkt \binop \edenote{e_2}\pkt & \text{definition of }\edenote\cdot \\
    = \edenote{e_1}(\pkt|_V) \binop \edenote{e_2}(\pkt|_V) & \text{by IHS since }\efvs(e_i) \subseteq \efvs(e_1 \binop e_2) \subseteq V, i = 1,2 \\
    = \edenote{e_1 \binop e_2}(\pkt|_V) & \text{definition of }\edenote\cdot
    \end{array}\]
  \item[($e = \unop e$)] Let $\pkt$ be given. Compute:
    \[\begin{array}{ll}
    \edenote{\unop e}\pkt \\
    = \unop \edenote{e}\pkt & \text{definition of }\edenote\cdot \\
    = \unop \edenote{e}(\pkt|_V) & \text{by IH, since } \efvs(e) = \efvs(\unop e) \subseteq V \\
    = \edenote{\unop e}(\pkt|_V) & \text{definition of }\edenote\cdot
    \end{array}\]
  \end{enumerate}
\end{proof}

\begin{lemma}[Satisfaction Projection]
  \label{lem:proj-satis}
  For every set of variables $V \subseteq \Var$, packet $\pkt \in \Pkt$ and
  boolean expression $b \in \BExpr$, such that $\bfvs(b) \subseteq V$,
  $\pkt \models b$ iff $\pkt|_V \models b$.
\end{lemma}

\begin{proof}
  Let $V \subseteq \Var$ be given.
  Proceed by induction on $b$, leaving $\pkt$ arbitrary.
  \begin{enumerate}[align=left]
  \item[($b = \FALSE$)] Immediate.
  \item[($b = b_1 \Rightarrow b_2$)]
    Let $\pkt$ be given. Compute:
    \[\begin{array}{ll}
    \pkt \models b_1 \Rightarrow b_2 \\
    \iff \pkt \not\models b_1 \text{or} \pkt\models b_2 & \text{by definition of } \models   \\
    \iff \pkt|_V \not\models b_1 \text{or} \pkt|_V \models b_2  & \text{by IHs, since} \bfvs(b_i) \subseteq \bfvs(b_1 \Rightarrow b_2) \subseteq V, i = 1,2  \\
    \iff \pkt|_V \models b_1 \Rightarrow b_2
    & \text{by definition of } \models
    \end{array}\]

  \item[($b = e_1 = e_2$)] Let $\pkt$ be given. Compute:
    \[\begin{array}{ll}
    \pkt \models e_1 = e_2 \\
    \iff \edenote{e_1}\pkt = \edenote{e_2}\pkt
    & \text{by definition of }\models \\
    \iff \edenote{e_1}(\pkt|_V) = \edenote{e_2}(\pkt|_V)
    & \text{by Lemma~\ref{lem:proj-expr}, since } \efvs(e_i) \subseteq \bfvs(e_1 = e_2) \subseteq V, i = 1,2 \\
    \iff \pkt|_V \models e_1 = e_2
    & \text{by definition of }\models
    \end{array}\]

  \end{enumerate}

\end{proof}


\begin{lemma}[Projection-Denotation Commutativity]
  \label{lem:proj-den-comm}
  For a closed action $c \in \Cmd$, $\fvs(c) \subseteq V \subseteq \Var$ and
  $\pkt \in \Pkt$, $\denote{c} \pkt =_V \denote{c} \pkt|_V$.
\end{lemma}

\begin{proof}
  Proceed by induction on $c$, leaving $\pkt$ general.
  \begin{enumerate}[align=left]
  \item[$(c = x:=e)$] Let $\pkt$ be given. Compute:
    \[\begin{array}{ll}
    (\denote{x:=e} (\pkt|_V))|_V\\
    = ((\pkt|_V)\{x:=\edenote{e}(\pkt|_V)\})|_V
    & \text{definition} \\
    = ((\pkt|_V)\{x := \edenote{e}\pkt\})|_V
    & \text{By Lemma~\ref{lem:proj-expr} since } \fvs(e) \subseteq \fvs(x := e) \subseteq V \\
    = (\pkt\{x := \edenote{e}\pkt\}|_V)|_V
    & \text{since } x \in \fvs(x:=e) \subseteq V \\
    = ((\denote{x:=e}\pkt)|_V)|_V
    & \text{by definition of }\denote{\cdot}\\
    = (\denote{x:=e}\pkt)|_V
    & \text{by Lemma~\ref{lem:proj-idem}}
    \end{array}\]
    The result follows by definition of $=_V$.

  \item[$(c = \havoc x)$] Contradictory; $\havoc x$ is not an action.
  \item[$(c = \assume b)$]
    Let $\pkt$ be given. Compute:
    \[\begin{array}{ll}
    (\denote{\assume b} \pkt)|_V \\
    = (\{\pkt \mid \pkt \models b\})|_V
    & \text{definition of}\denote\cdot\\
    = ((\{\pkt \mid \pkt \models b\})|_V)|_V
    & \text{By Lemma~\ref{lem:proj-idem-set}} \\
    = (\{\pkt|_V \mid \pkt \models b\})|_V
    & \text{definition of }(\cdot)|_V : \mathcal P (\Pkt) \to \mathcal P (\Pkt) \\
    = (\{\pkt|_V \mid \pkt|_V \models b\})|_V
    & \text{By Lemma~\ref{lem:proj-satis} since } \fvs(b) \subseteq \fvs(\assume b) \subseteq V \\
    = (\denote{\assume b}(\pkt|_V))|_V
    & \text{by definition of}\denote\cdot
    \end{array}
    \]
    The result follows by definition of $=_V$.

  \item[$(c = \assert b)$] \textit{sim.}
  \item[$(c = c_1;c_2)$] Let $\pkt$ be given. Compute:
    \[\begin{array}{>{\displaystyle}ll}
    (\denote{c_1;c_2}\pkt)|_V \\
    = (\denote{c_2}^\dagger(\denote{c_1}\pkt))|_V
    & \text{definition of }\denote\cdot \\
    = \left(\bigcup_{\pkt' \in \denote{c_1} \pkt} \denote{c_2}\pkt'\right)|_V
    & \text{definition of }(\cdot)^\dagger \\
    = \bigcup_{\pkt' \in \denote{c_1} \pkt} (\denote{c_2}\pkt')|_V
    & \text{by Lemma~\ref{lem:proj-union-set}} \\
    = \bigcup_{\pkt' \in \denote{c_1}\pkt} (\denote{c_2}(\pkt'|_V))|_V
    & \text{IH}(c_2)  \\
    =\bigcup_{\pkt' \in (\denote{c_1}\pkt)|_V} (\denote{c_2} \pkt')|_V
    & \text{by set theory} \\
    = \bigcup_{\pkt' \in (\denote{c_1}(\pkt|_V))|_V} (\denote{c_2} \pkt')|_V
    & \text{by IH}(c_1) \\
    = \bigcup_{\pkt' \in \denote{c_1}(\pkt|_V)} (\denote{c_2} (\pkt'|_V))|_V
    & \text{by set theory} \\
    = \bigcup_{\pkt' \in \denote{c_1}(\pkt|_V)} ((\denote{c_2} \pkt')|_V)|_V
    & \text{by IH}(c_2) \\
    = \bigcup_{\pkt' \in \denote{c_1}(\pkt|_V)} (\denote{c_2} \pkt')|_V
    & \text{by Lemma~\ref{lem:proj-idem-set}} \\
    = \left(\bigcup_{\pkt' \in \denote{c_1}(\pkt|_V)} \denote{c_2}\pkt'\right)|_V
    & \text{by Lemma~\ref{lem:proj-union-set}} \\
    = \denote{c_2}^\dagger(\denote{c_1}(\pkt|_V))|_V
    & \text{By definition of }(\cdot)^\dagger\\
    = (\denote{c_1;c_2}(\pkt|_V))|_V
    & \text{By definition of }\denote\cdot
    \end{array}\]
    The result follows by definition of $=_V$.

  \item[$(c = c_1 \choice c_2)$] Let $\pkt$ be given.
    \[\begin{array}{ll}
    (\denote{c_1\choice c_2}\pkt)|_V \\
    = (\denote{c_1}\pkt \cup \denote{c_2}\pkt)|_V
    & \text{By definition of }\denote\cdot \\
    = (\denote{c_1}\pkt)|_V \cup (\denote{c_2}\pkt)|_V
    & \text{By Lemma~\ref{lem:proj-union-set}} \\
    = (\denote{c_1}(\pkt|_V))|_V \cup (\denote{c_2}(\pkt|_V))|_V
    & \text{By IHs} \\
    = ((\denote{c_1}(\pkt|_V) \cup \denote{c_2}(\pkt|_V))|_V)|_V
    & \text{By Lemma~\ref{lem:proj-union-set}} \\
    = (\denote{c_1}(\pkt|_V) \cup \denote{c_2}(\pkt|_V))|_V
    & \text{By Lemma~\ref{lem:proj-idem-set}}\\
    = (\denote{c_1 \choice c_2}(\pkt|_V))|_V
    & \text{By definition of }\denote\cdot \\
    \end{array}\]

    The result follows by definition of $=_V$.

  \item[$(c = t.\apply())$] Contradictory; $t.\apply()$ is not an action.
  \end{enumerate}

\end{proof}




\subsection{Lemmas}

\begin{lemma}[Input-Congruence]
  \label{lem:input-congruence}
  For $c,c',c_0 \in \Cmd$,
  if for all $\sigma \in \State$ and $\pkt \in \Pkt$, $\denote{c}^\sigma \pkt = \denote{c'}^\sigma \pkt$,
  then for all $\sigma \in \State$ and $\pkt \in \Pkt$, $\denote{c_0;c}^\sigma \pkt = \denote{c_0;c'}^\sigma\pkt$.
\end{lemma}
\begin{proof}
  Let $c$, $c'$, $c_0$, $\sigma$ and $\pkt$ be given as above.
  Let $\pkt_0 \in \denote{c_0}^\sigma \pkt$. By assumption $\denote{c}^\sigma \pkt_0 = \denote{c'}^\sigma \pkt_0$.
  Conclude ${\denote{c}^\sigma}^\dagger\left(\denote{c_0}^\sigma\pkt\right) = {\denote{c'}^\sigma}^\dagger\left(\denote{c_0}^\sigma\pkt\right)$. The result follows

\end{proof}


\begin{lemma}[Congruence]
  \label{lem:congruence}
  For $c,c',c_a,c_b \in \Cmd$,
  if for all $\sigma \in \State$ and $\pkt \in \Pkt$, $\denote{c}^\sigma \pkt = \denote{c'}^\sigma \pkt$,
  then for all $\sigma \in \State$ and $\pkt \in \Pkt$, $\denote{c_a;c;c_b}^\sigma \pkt = \denote{c_a;c';c_b}^\sigma\pkt$.
\end{lemma}

\begin{proof}
  Let $\sigma \in \State$ and $\pkt \in \Pkt$ be arbitrary. Compute:
  \[\begin{array}{ll}
  \denote{c_a;c;c_b}^\sigma \pkt \\
  = {\denote{c_b}^\sigma}^\dagger\left({\denote{c}^\sigma}^\dagger\left(\denote{c_a}^\sigma \pkt\right)\right)\\
  = {\denote{c_b}^\sigma}^\dagger\left({\denote{c'}^\sigma}^\dagger\left(\denote{c_a}^\sigma \pkt\right)\right)
  & \text{By Lemma~\ref{lem:input-congruence}}\\
  =\denote{c_a;c;c_b}^\sigma \pkt \\
  \end{array}\]
\end{proof}

\begin{remark}
  The proofs that follow rely so heavily on Lemma~\ref{lem:congruence}, that we omit recording it's use for simplicity.
\end{remark}

\begin{lemma}[Assume-Currying]
  \label{lem:assume-currying}
  For $b_1,b_2 \in \BExpr$, $\sigma : \Value \to \Row^*$,
  \[\forall \pkt. \denote{\assume {b_1\wedge b_2}}^\sigma \pkt = \denote{\assume {b_1};\assume {b_2}}^\sigma \pkt\]
\end{lemma}
\begin{proof}
  Let $b_1,b_2,\sigma, \pkt$ be arbitrary. Compute using the definitions of $\denote\cdot$ and $\models$.
  \[\begin{array}{ll}
  \denote{\assume {b_1 \wedge b_2}}^\sigma \pkt \\
  = \{\pkt \mid \pkt \models b_1 \wedge b_2\} \\
  = \{\pkt \mid \pkt \models b_1, \pkt \models b_2\} \\
  = {\denote{\assume{b_1}}^\sigma}^\dagger\{\pkt \mid \pkt \models b_1\} \\
  = \denote{\assume{b_1}; \assume{b_2}}^\sigma \pkt
  \end{array}\]
\end{proof}


\begin{lemma}[Products and Sums]
  \label{lem:prod-sum}
  For $c_1,c_2, c_3 \in \Cmd$, $\sigma : \Value \to \Row^*$, $\pkt \in \Pkt$.
  $\denote{c_1;(c_2 \choice c_3)}^\sigma\pkt = \denote{c_1;c_2 \choice
    c_1;c_3}^\sigma\pkt$.
\end{lemma}
\begin{proof}
  Let $c_1,c_2,c_3$, $\sigma$, and $\pkt$ be given as above. Compute:
  \[
  \begin{array}{ll}
  \denote{c_1;(c_2 \choice c_3)}^\sigma \pkt \\
  = {\denote{c_2 \choice c_3}^\sigma}^\dagger\left(\denote{c_1}^\sigma\pkt\right) \\
  = {\denote{c_2}^\sigma}^\dagger\left(\denote{c_1}^\sigma \pkt\right)
  \cup {\denote{c_3}^\sigma}^\dagger\left(\denote{c_1}^\sigma \pkt\right) \\
  = {\denote{c_1;c_2}^\sigma}\pkt\cup {\denote{c_1;c_3}^\sigma}\pkt
  \end{array}
  \]
\end{proof}





\begin{lemma}[Pseudo-Parametricity]
  \label{lem:parametricity}
  For $c \in \Cmd$, $\sigma \in \State$, $y \in \Var$, $\pkt \in \Pkt$, if $y
  \not\in \fvs(c)$, then $\forall \pkt' \in \denote{c}^\sigma \pkt$, $\pkt'(y) =
  \pkt(y)$.
\end{lemma}

\begin{proof}
  Let $\sigma : \State $, $y \in \Var$, and $\pkt \in \Pkt$ be given.
  Proceed by induction on $c$.
  \begin{enumerate}[align=left]
  \item[($c = x := e$)] Assume $y \not \in \fvs(x:=e)$, that is, $y \neq x$.
    Compute $\denote{x:=e}^\sigma \pkt = \{\pkt\{ x \mapsto \edenote e
    \pkt\}\}$. Observe that $\pkt\{ x \mapsto \edenote e \pkt\}(y) = \pkt(y)$
    since $y \neq x$. The result follows.

  \item[($c = \havoc x$)] Assume $y \not \in \fvs(\havoc x)$, that is $y \neq
    x$. Compute $\denote{\havoc x}^\sigma\pkt = \{\pkt\{x \mapsto v\} | v \in
    \Value\}$. let $v \in \Value$ be arbitrary. Observe that since $x \neq y$,
    $\pkt\{x \mapsto v\}(y) = \pkt(y)$. The result follows.

  \item[($c = \assume b$)] Assume $y \not \in \fvs(\assume b)$, that is $y
    \not\in \bfvs(b)$. Compute $\denote{\assume b}^\sigma \pkt = \{\pkt \mid
    \pkt \models b\}$. If $\pkt \not\models b$ the result holds vacuously.
    Otherwise the result follows from $\pkt(y) = \pkt(y)$.

  \item[$(c = \assert b)$] \textit{sim}.

  \item[$(c = c_1;c_2)$] Assume $y \not \in \fvs(c_1;c_2)$. Consequently $y
    \not\in \fvs(c_1)$, and $y \not \in \fvs(c_2)$. By IH$(c_1)$, $\forall
    \pkt_1 \in \denote{c_1}^\sigma(\pkt)$, $\pkt_1(y) = pkt(y)$. Pick an
    arbitrary $\pkt_1 \in \denote{c_1}^\sigma(\pkt)$. By IH$(c_2)$, $\forall
    \pkt_2 \in \denote{c_1}^\sigma(\pkt_1)$, $\pkt_2(y) = \pkt_1(y)$. By
    transitivity, we have $\pkt_2(y) = \pkt(y)$. Conclude that $\forall \pkt_2
    \in {\denote{c_2}^\sigma}^\dagger (\denote{c_1}^\sigma \pkt)$, $\pkt_2(y) =
    \pkt_1(y)$.

  \item[$(c = c_1 \choice c_2)$] Assume $y \not \in \fvs(c_1 \choice c_2)$.
    Consequently, $y \not \in \fvs(c_1)$ and $y \not \in \fvs(c_2)$.
    By IH$(c_i)$, $\forall \pkt' \in \denote(c_i)^\sigma\pkt$, for $i = 1,2$.
    By definition of $\denote{\cdot}$, the result follows.

  \item[$(t.\apply())$] Assume $y \not\in \fvs(t.\apply())$.
    There are two cases. Either $\pkt$ hits in the table or it misses.
    \begin{enumerate}[align=left]
    \item[\textit{Case 1}.] Assume that there is a row $r$ such that $\pkt
      \models t.\matchrow(r)$. Then $\denote{t.\apply()}^\sigma \pkt =
      \denote{t.\action[r.\action](r.\data)} \pkt$. The result follows by the
      IH.

    \item[\textit{Case 2}.] Conversely, there is no such row, in which case
      $\denote{t.\apply()}^\sigma\pkt = \{\pkt\}$, in which case the result is
      trivial.
    \end{enumerate}
  \end{enumerate}
\end{proof}

\begin{lemma}[Set Pseudo-Parametricity]
  \label{lem:parametricity-set}
  For $c \in \Cmd$, $\sigma : \State$, $y \in \Var$, $\pkt \in \Pkt$, if $Y
  \subseteq \Var \setminus \fvs(c)$, then $\forall \pkt' \in \denote{c}^\sigma
  \pkt$, $\pkt'(y) = \pkt(y)$.
\end{lemma}

\begin{proof}
By Lemma~\ref{lem:parametricity}.
\end{proof}


\begin{lemma}[Unused-Variable Expression Noninterference]
  \label{lem:exp-param-noninter}
  For $e \in \BVExpr$, $\pkt \in \Pkt$,
  $\{v_1,v_2\} \subseteq \Value$, $y \in \Var \setminus \efvs(e) $,
  $\edenote{e}\pkt\{y \mapsto v_1\} = \edenote{e}pkt\{y \mapsto v_2\}$.
\end{lemma}
\begin{proof}
  Let $\pkt$, $v_1$, $v_2$, and $y$ be given as above. Proceed by induction on
  $e$.
  \begin{enumerate}[align=left]
    \item[$(e = v)$] Compute: $\edenote{v}\pkt\{y
      \mapsto v_1\} = v = \edenote{v}pkt\{y \mapsto v_2\}$.
    \item[$(e = x)$] Since $y \not\in \efvs(x)$, conclude $y \neq x$. Compute:
      $\edenote{x}\pkt\{y \mapsto v_i\} = \pkt\{y \mapsto v_i\}(x) = \pkt(x) $
      for $i = 1,2$. The result follows.

    \item[$(e = e_1 \binop e_2)$]
      Note that $\efvs(e_i) \subseteq \efvs(e_1 \binop e_2)$ for $i = 1,2$. Compute
      \[\begin{array}{ll}
      \edenote{e_1 \binop e_2}\pkt\{y \mapsto v_1\} \\
      = \edenote{e_1}\pkt{y \mapsto v_1} \binop \edenote{e_2}\pkt\{y \mapsto v_1\} \\
      = \edenote{e_1}\pkt{y \mapsto v_2} \binop \edenote{e_2}\pkt\{y \mapsto v_2\} & \text{By IH}(e_i), i = 1,2\\
      = \denote{e_1 \binop e_2}\pkt\{y \mapsto v_2\}
      \end{array}
      \]

    \item[$(e = \unop e)$]
      Note that $\efvs(e) \subseteq \efvs(\unop e)$. Compute:
      \[\begin{array}{ll}
      \edenote{\unop e}\pkt\{y \mapsto v_1\} \\
      = \unop \edenote{e}\pkt\{y \mapsto v_1\} \\
      = \unop \denote{e}\pkt\{y \mapsto v_2\} & \textit{by IH}(e)\\
      = \denote{\unop e}\pkt\{y \mapsto v_2\}
      \end{array}\]
  \end{enumerate}
\end{proof}


\begin{lemma}[Unused-Variable Boolean Noninterference]
  \label{lem:bool-noninter}
  For $b \in \BExpr$, $\pkt \in \Pkt$,
  $\{v_1,v_2\} \subseteq \Value$, $y \in \Var \setminus \bfvs(b) $,
  $\pkt\{y \mapsto v_1\} \models b \iff pkt\{y \mapsto v_2\} \models b$.
\end{lemma}

\begin{proof}
  Let $\pkt$, $v_1$, $v_2$, and $y$ be given as above.
  Proceed by induction on $b$:
  \begin{enumerate}[align=left]
  \item[($b = \FALSE$)] Trivial.
  \item[($b = b_1 \Rightarrow b_2$)] Since $y \not \in\bfvs(b_1 \Rightarrow b_2) =
    \bfvs(b_1) \cup \bfvs(b_2)$, $y \not \in \bfvs(b_i)$, for $i = 1,2$. Compute
    as follows:
    \[\begin{array}{ll}
    \pkt\{y \mapsto v_1\} \models b_1 \Rightarrow b_2 \\
    \iff \pkt\{y \mapsto v_1\} \not\models b_1 \text{ or } \pkt\{y \mapsto v_1\} \models b_2 \\
    \iff \pkt\{y \mapsto v_2\} \not\models b_1 \text{ or } \pkt\{y \mapsto v_2\} \models b_2
    & \text{by IHs since } y \not \in \bfvs(b_i), i = 1,2 \\
    \iff \pkt\{y \mapsto v_2\} \models b_1 \Rightarrow b_2
    \end{array}\]

  \item[$(b = e_1 = e_2)$] Since $y \not \in\bfvs(e_1 = e_2) = \efvs(e_1) \cup
    \efvs(e_2)$, $y \not \in \bfvs(e_i)$ for $i =1,2$. Compute as follows:
    \[\begin{array}{ll}
    \pkt\{y \mapsto v_1\} \models e_1 = e_2 \\
    \iff \edenote{e_1}\pkt\{y \mapsto v_1\} = \edenote{e_2}\pkt\{y \mapsto v_1\} \\
    \iff\edenote{e_1}\pkt\{y \mapsto v_2\} = \edenote{e_2}\pkt\{y \mapsto v_2\} & \text{by Lemma~\ref{lem:exp-param-noninter}} \\
    \iff \pkt\{y\mapsto v_2\} \models e_1 = e_2
    \end{array}
    \]
  \end{enumerate}
\end{proof}

\begin{lemma}[Unused Variable Noninterference]
  \label{lem:param-noninter}
  For $c \in \Cmd$, $\sigma : \State$, $\pkt \in \Pkt$,
  $\{v_1,v_2\} \subseteq \Value$, $y \in \Var \setminus \fvs(c)$,
  $\denote{c}^\sigma \pkt\{y \mapsto v\} =_{\Var \setminus \{y\}}\denote{c}^\sigma\pkt\{y \mapsto v\}$.
\end{lemma}

\begin{proof}
  Let $\sigma$, $v_1$, $v_2$, and $y$ be given.
  Proceed by induction on $c$, leaving $\pkt$ and $x$ general.
  \begin{enumerate}[align=left]
  \item[$(c = z := e)$]
    Let $\pkt$ be given. Since $y \not\in \fvs(z := e)$ we know that $y \neq z$.
    Compute:
    \[\begin{array}{ll}
    \pkt' \in \denote{z:=e}^\sigma (\pkt\{y \mapsto v\}) \\
    \iff \pkt' \in \{\pkt\{y \mapsto v\}\{z \mapsto \edenote{e}(\pkt\{y\mapsto v\})\}\}\\
    \iff \pkt' = \pkt\{y \mapsto v\}\{z \mapsto \edenote{e}(\pkt\{y\mapsto v\})\}
    \end{array}
    \]
    Similarly, compute:
    \[\begin{array}{ll}
    \pkt'' \in \denote{z:=e}^\sigma (\pkt\{y \mapsto v'\})\\
    \iff \pkt'' \in \{\pkt\{y \mapsto v'\}\{z \mapsto \edenote{e}(\pkt\{y\mapsto v'\})\}\}\\
    \iff \pkt'' = \pkt\{y \mapsto v'\}\{z \mapsto \edenote{e}(\pkt\{y\mapsto v'\})\}
    \end{array}
    \]

    We need to show that
    \[\forall x \in \Var \setminus \{y\}.
    \pkt\{y \mapsto v'\}\{z \mapsto \edenote{e}(\pkt\{y\mapsto v'\})(x)
    = \pkt\{y \mapsto v\}\{z \mapsto \edenote{e}(\pkt\{y\mapsto v\})\}(x)
    \]

    Equivalently we can show
    \[\forall x \in \Var \setminus \{y\}.
    \pkt\{z \mapsto \edenote{e}(\pkt\{y\mapsto v'\})(x)
    = \pkt\{z \mapsto \edenote{e}(\pkt\{y\mapsto v\})\}(x)
    \]

    Let $x \neq y$ be given. The result is immediate if $x \neq z$. Otherwise we
    must show that $\edenote{e}(\pkt\{y \mapsto v\}) = \edenote{e}(\pkt\{y
    \mapsto v'\})$. Since $y \not \in \efvs(e)$, this follows by
    Lemma~\ref{lem:exp-param-noninter}.


  \item[$(c = \havoc z)$] Let $\pkt$ by given. Since $y \not \in \fvs(\havoc z)$, we know $y \neq z$.
    Compute:
    \[\begin{array}{ll}
    \denote{\havoc z}^\sigma\pkt\{y \mapsto v_1\} \\
    = \{\pkt\{y \mapsto v_1\}\{z \mapsto v_z\} \mid v_z \in \Value\}\\
    =_{\Var \setminus \{y\}} \{\pkt\{y \mapsto v_2\}\{z \mapsto v_z\} \mid v_z \in \Value\} \\
    = \denote{\havoc z}^\sigma\pkt\{y \mapsto v_2\}
    \end{array}
    \]

    The result follows by Lemma~\ref{lem:equal-proj}.

  \item[$(c = \assume b)$]
    Let $\pkt$ by given. Since $\bfvs(b) \subseteq \fvs(\assume b)$, $y \not\in \bfvs(b)$.
    Compute \[
    \begin{array}{ll}
      \denote{\assume b}^\sigma \pkt\{y \mapsto v_1\} \\
      = \{\pkt \mid \pkt\{y \mapsto v_1\} \models b\}\\
      =_{\Var \setminus \{y\}} \{\pkt \mid \pkt\{y \mapsto v_2\} \models b\} & \text{by Lemma~\ref{lem:bool-noninter}, since }y \not\in \bfvs(b) \\
      = \denote{\assume b}^\sigma \pkt\{y \mapsto v_2\}
    \end{array}
    \]

    The result follows by Lemma~\ref{lem:equal-proj}.

    \item[$(c = \assert b)$] \textit{sim}.
    \item[$(c = c_1;c_2)$] Observe that $\fvs(c_i) \subseteq \fvs(c_1;c_2)$ for
      $i = 1,2$, which enables both IHS. Observe that:
      \[\begin{array}{ll}
      \denote{c_1;c_2}^\sigma\pkt\{y \mapsto v_1\}
      = {\denote{c_2}^\sigma}^\dagger\left(\denote{c_1}^\sigma\pkt\{y\mapsto v_1\}\right) \\
      \end{array}
      \]
      If $c_1$ denotes $\error$, the result is immediate, so assume otherwise.

      Let $\{i,j\} \subseteq \{1,2\}$. Let $\pkt_i \in
      \denote{c_1}^\sigma\pkt\{y \mapsto v_i\}$ be arbitary. By
      Lemma~\ref{lem:parametricity}, we know that $\pkt_i(y) = v_i$. Further
      IH$(c_1)$ tells us that there is some $\pkt_j \in
      \denote{c_1}^\sigma\pkt\{y\mapsto v_j\}$ such that $\pkt_1 =_{\Var
        \setminus \{y\}} \pkt_j$. Again, IH$(c_1)$ tells us that $\pkt_j(y) =
      v$. Consequently, we can write $\pkt_i$ and $\pkt_j$ in terms of a another
      packet $\pkt'$, i.e $\pkt_k = \pkt'\{y \mapsto v_k\}$ for $k = i,j$. Then
      by IH$(c_2)$, $\denote{c_2}^\sigma\pkt'\{y \mapsto v_i\} =_{\Var \setminus \{y\}}
      \denote{c_2}^\sigma \pkt'\{y \mapsto v_j\}$. Conclude that
      $\denote{c_1}^\sigma\pkt\{y \mapsto v_i\} \subseteq_{\Var \setminus \{y\} }
      \denote{c_1}^\sigma\pkt\{y \mapsto v_j\}$.

      We just proved that the projected subset is bidrectional, i.e. that
      $\denote{c_1}^\sigma\pkt\{y \mapsto v_1\} =_{\Var \setminus\{y\}}
      \denote{c_1}^\sigma\pkt\{y \mapsto v_2\}$

    \item[$(c = c_1 \choice c_2)$] Observe that $\fvs(c_i) \subseteq \fvs(c_1 \choice c_2)$ for
      $i = 1,2$, which enables both IHs. Compute as follows
      \[\begin{array}{ll}
      \denote{c_1 \choice c_2}^\sigma\pkt\{y \mapsto v_1\} \\
      = \denote{c_1}^\sigma\pkt\{y \mapsto v_1\} \cup \denote{c_2}^\sigma\pkt\{y \mapsto v_1\} \\
      =_{\Var \setminus \{y\}} \denote{c_1}^\sigma\pkt\{y \mapsto v_2\} \cup \denote{c_2}^\sigma\pkt\{y \mapsto v_2\}
      & \text{by IHs} \\
      = \denote{c_1 \choice c_2}
      \end{array}
      \]

      The result follows by Lemma~\ref{lem:equal-proj}.

    \item[$(c = t.\apply())$]
      There are two cases, corresponding to hitting and missing.
      \begin{enumerate}[align=left]
      \item[\textit{Case 1}.] Assume there is some $r \in \sigma(t)$ such that
        $\pkt\{y \mapsto v_1\} \models t.\matchrow(r)$, and that $r$ is the
        minimally-indexed such row. Then by Lemma~\ref{lem:bool-noninter},
        $\pkt\{y \mapsto v_2\} \models t.\matchrow(r)$, and is the minimally indexed such row. Then, since
        $\fvs(t.\action[r.\action](r.\data)) \subseteq \fvs(t.\apply())$, the
        result follows by IH$(t.\action[r.\action](r.\data))$.

        \item[\textit{Case 2}.] Assume there is no $r \in \sigma(t)$ such that
          $\pkt\{y \mapsto v_1\} \models t.\matchrow(r)$. Then by
          Lemma~\ref{lem:bool-noninter}, there is now $r \in \sigma(t)$ such
          that $\pkt\{y \mapsto v_2\} \models t.\matchrow(r)$. Then by definitions:
          \[\denote{t.\apply()}^\sigma \pkt\{y \mapsto v_1\} = \{\pkt\{y \mapsto v_1\}\} = \{\pkt\{y \mapsto v_2\}\} = \denote{t.\apply()}^\sigma \pkt\{y \mapsto v_2\}\]
          The result follows by Lemma~\ref{lem:equal-proj}.
      \end{enumerate}

  \end{enumerate}
\end{proof}


\begin{lemma}[Unused Variable Set Noninterference]
  \label{lem:param-noninter-set}
  For $c \in \Cmd$, $\sigma : \State$, $\pkt \in \Pkt$,
  $\{v_1,v_2\} \subseteq \Value$, $Y \subseteq \Var \setminus \fvs(c)$,
  $\denote{c}^\sigma \pkt\{y \mapsto v\} =_{\Var \setminus Y}\denote{c}^\sigma\pkt\{y \mapsto v\}$.
\end{lemma}

\begin{proof}
  By Lemma~\ref{lem:param-noninter}.
\end{proof}


\begin{lemma}[Disjoint Commutativity]
  \label{lem:disj-comm}
  For $c_1,c_2 \in \Cmd$, and $\sigma \in \State$ if $\fvs(c_1) \cap
  \fvs(c_2) = \emptyset$, $ \forall \pkt \in \Pkt. \denote{c_1;c_2}^\sigma\pkt =
  \denote{c_2;c_1}^\sigma \pkt$.
\end{lemma}
\begin{proof}
  Let $c_1, c_2$, $\sigma$, and $\pkt$ be given as above. Let $V = \Var
  \setminus (\fvs(c_1)\cup \fvs(c_2))$Let $P_i = \denote{c_i}^\sigma \pkt$ for
  $i = 1,2$, and $P_{ij} = { \denote{c_j}^\sigma}^\dagger P_i$ for $\{i,j\} =
  \{1,2\}$. Note that $P_{ij} = \denote{c_i;c_j}^\sigma \pkt$.

  It suffices to show, without loss of generality, for $\pkt' \in P_{12}$,
  there exists $\pkt_1 \in P_1$ and $\pkt_2 \in P_2$ such that
  \[\pkt'(x) = \begin{cases}
    \pkt_1(x),& \text{if } x \in \fvs(c_1)\\
    \pkt_2(x),& \text{if } x \in \fvs(c_2)\\
    \pkt(x), & \text{if } x \in V
  \end{cases} \]


  Let $\pkt' \in P_{12}$ be arbitrary. By definition, there exists $\pkt_1 \in
  P_1$ such that $\pkt' \in \denote{c_2}^\sigma \pkt_1$. By
  Lemma~\ref{lem:parametricity}, $\pkt'=_{\fvs(c_1)} \pkt_1$, so our first goal
  is done. Further, by Lemma~\ref{lem:parametricity}, $\pkt_1 =_{\fvs(c_2)}
  \pkt(x)$. So by Lemma~\ref{lem:param-noninter}, there is $\pkt_2 \in P_2$
  such that $\pkt'(x) =_{\fvs(c_2)} \pkt_2(x)$. Then by
  Lemma~\ref{lem:parametricity}, we know that $\pkt'(x) =_V \pkt(x)$. The result
  follows.
\end{proof}


\section{Encoding}

Now we will define a collection of source-to-source translations that deal with
the controller interface.

\subsection{Eliminating Tables}

The first thing to do is to define a source-to-source translation that
eliminates the tables. The observation here is that tables essentially represent
if-else statements, so once we have a state $\sigma$ in hand we can rewrite the
program to a command $c[\sigma] \in \Cmd$ that uses no tables. This translation
is defined in Figure~\ref{fig:table-elim}

\begin{figure}
  \[\begin{array}{r>{\triangleq}cl}
  \multicolumn{3}{l}{(\cdot)[\sigma] : \Cmd \to \Cmd} \\
  (x := e)[\sigma] && h.f := e \\
  (\havoc x)[\sigma] && \havoc x \\
  (\assume b)[\sigma] && \assume b \\
  (\assert b)[\sigma] && \assert b \\
  (c_1;c_2)[\sigma] && c_1[\sigma];c_2[\sigma] \\
  (c_1 \choice c_2)[\sigma] && c_1[\sigma] \choice c_2[\sigma] \\
  %% (\{c\})[\sigma] && \{c[\sigma]\} \\
  (t.\apply())[\sigma] &&
  \begin{array}[t]{l}
    (\\
    \quad \assume {t.\matchrow(r_1)};\\
    \quad t.\action[r_1.\action](r_1.\data)\\
    )~\choice\\
    \phantom)~\,\vdots\\
    \phantom)\,\choice~(\\
    \quad \assume {t.\matchrow(r_n)};\\
    \quad \assume {\bigwedge_{i=1}^{n-1}{\neg t.\matchrow(r_i)}};\\
    \quad t.\action[r_n.\action](r_n.\data)\\
    )\choice (\\
    \quad \assume {\bigwedge_{i=1}^n \neg t.\matchrow(r_i)};\\
    \quad \SKIP \\
    )\\
    \textrm{where}~[r_1;\ldots;r_n] = \sigma(t.\id)
  \end{array}
  \end{array}
  \]
  \caption{Table Substitution}
  \label{fig:table-elim}
\end{figure}


\begin{theorem}[Table Substitution]
  \label{thm:subst}
  For every $c \in \Cmd$, well-formed state $\sigma : \Value \to \Row^*$, and
  packet $\pkt \in \Pkt$,
  \[\denote{c}^\sigma\pkt = \denote{c[\sigma]}\,\pkt\]
\end{theorem}
\begin{proof}
   Proceed by induction on the structure of $c$.
  \begin{enumerate}[align=left]
    \item[$(c = (x := e))$] Immediate, since $(x:=e)[\sigma] = (x:=e)$.

    \item[$(c = \havoc x)$] Immediate, since $(\havoc x)[\sigma] = \havoc x$.

    \item[$(c = \assume b)$] Immediate, since $(\assume b)[\sigma] = (\assume b)$.

    \item[$(c = \assert b)$] Immediate, since $(\assert b)[\sigma] = (\assert b)$.


    \item[$(c = c_1;c_2)$] Let $\pkt,\sigma$ be arbitrary. Compute as follows
      \[\begin{array}{ >{\displaystyle}l l}
        \denote{(c_1;c_2)[\sigma]}\,\pkt \\
        = \denote{c_1[\sigma];c_2[\sigma]}\,\pkt  & \text{definition of } (\cdot)[\sigma]\\
        = \bigcup_{\pkt' \in \denote{c_1[\sigma]}\,\pkt} \denote{c_2[\sigma]}\pkt' & \text{definition of } \denote{\cdot}\\
        = \bigcup_{\pkt' \in \denote{c_1[\sigma]}\,\pkt} \denote{c_2}^\sigma\pkt' & \text{IH}(c_2) \\
        = \bigcup_{\pkt' \in \denote{c_1}^\sigma\pkt} \denote{c_2}^\sigma\pkt' & \text{IH}(c_1) \\
        = \denote{c_1;c_2}^\sigma\pkt & \text{definition of } \denote{\cdot}^\sigma
      \end{array}\]

    \item[$(c = c_1 \choice c_2)$] Let $\pkt, \sigma$ be arbitrary. Compute as follows:
      \[ \begin{array}{>{\displaystyle}ll}
          \denote{c_1\choice c_2[\sigma]}\,\pkt\\
          = \denote{c_1[\sigma] \choice c_2[\sigma]}\,\pkt & \text{definition of } (\cdot)[\sigma]\\
          = \denote{c_1[\sigma]}\,\pkt \cup \denote{c_2[\sigma]}\,\pkt & \text{definition of } \denote{\cdot}\\
          = \denote{c_1}^\sigma\pkt \cup \denote{c_2[\sigma]}\,\pkt & \text{IH}(c_1)\\
          = \denote{c_1}^\sigma\pkt \cup \denote{c_2}^\sigma\,\pkt & \text{IH}(c_2)\\
          = \denote{c_1\choice c_2}^\sigma\pkt & \text{definition of } \denote{\cdot}^\sigma
          \end{array}
      \]

    \item[$(c = t.\apply())$] Let $\pkt,\sigma$ be arbitrary. Let $[r_1, \ldots,
      r_n] = \sigma(t)$.

      Compute as follows:
      \[
      \begin{array}{ll}
        \denote{(t.\apply())[\sigma]}\,\pkt\\
        = \denote{
          \begin{array}{l}
            \bigchoice_{i=1}^{n}
            \begin{array}{l}
              \assume t.\matchrow(r_i);\\
              \assume \bigwedge_{j=1}^{i-1}\neg t.\matchrow(r_j)\\
              t.\action[r_i.\action](r_i.data)
            \end{array} \\
            \choice \assume \bigwedge_{i=1}^{n} \neg  t.\matchrow(r_j); \SKIP
        \end{array}}\pkt \\
        = \begin{array}{l}
          \bigcup_{i=1}^{|\sigma(t)|}
          \denote{
            \begin{array}{l}
              \assume t.\matchrow(r_i);\\
              \assume \bigwedge_{j=1}^{i-1}\neg t.\matchrow(r_j)\\
              t.\action[\sigma(t)[i]](r_i.data)
            \end{array}}\,\pkt\\
            \cup \denote{\assume \bigwedge_{i=1}^{n} \neg  t.\matchrow(r_j); \SKIP}\,\pkt
        \end{array} \\
        \end{array}
      \]
      Now consider the two cases.

      \begin{enumerate}
      \item[\textit{Case 1}.] Assume that there is some $i \in \{1,\ldots,
        n\}$ such that $\pkt \models t.\matchrow(r_i)$. Let $i$ be the
        smallest such $i$. Then by definition $\denote{t.\apply()}^\sigma =
        \denote{t.\action[r_i.\action](r_i.\data)}^\sigma\,\pkt$. Since it is
        the smallest, it must be the that $\pkt \not\models t.\matchrow(r_j)$
        for $1 \leq j < i$.This is equivalent to saying that $\pkt
        \models\bigwedge_{j=1}^{i-1}\neg t.\matchrow(r_j)$. Consequently,
        $\denote{t.\action[r_i.\action](r_i.\data)}\,\pkt \subseteq
        \denote{t.\apply()[\sigma]}$. In fact this is an equality.

        Because $i$ is the smallest index satisfying $\pkt \models
        t.\matchrow(r_i)$, for all rows $r_j$ with $j < i$, $\denote{\assume
          t.\matchrow(r_j)} = \emptyset$, and so the following holds: \[
          \denote{
          \begin{array}{l}
            \assume t.\matchrow(r_j);\\
            \assume \bigwedge_{j=1}^{i-1}\neg t.\matchrow(r_j)\\
            t.\action[\sigma(t)[i]](r_i.data)
        \end{array}}\,\pkt = \emptyset
          \]

        Now, for every index $j > i$, it may be that $\denote{\assume
          t.\matchrow(r_j)} \neq \emptyset$, but because $\pkt \models
        t.\matchrow(r_i)$, and $i < j$, we know $\denote{\bigwedge_{j=1}^{i-1}
          \neg t.\matchrow(r_j)} = \emptyset$, so conclude that \[
          \denote{
          \begin{array}{l}
            \assume t.\matchrow(r_j);\\
            \assume \bigwedge_{j=1}^{i-1}\neg t.\matchrow(r_j)\\
            t.\action[\sigma(t)[i]](r_i.data)
        \end{array}}\,\pkt = \emptyset
          \]

        Similarly, $\denote{\assume \bigwedge_{i=1}^{n} \neg t.\matchrow(r_j)} =
        \emptyset$, so conclude that $\denote{\assume \bigwedge_{i=1}^{n} \neg
          t.\matchrow(r_j);\SKIP} = \emptyset$


        Conclude that $\denote{t.\apply()[\sigma]} =
        \denote{t.\action[r_i.\action](r_i.\data)}^\sigma\,\pkt$. The result
        follows by applying the IH to $t.\action[r_i.\action](r_i.\data)$.

        \item[\textit{Case 2.}] Assume that for all $i \in \{1, \ldots, n\}$,
          $\pkt \not\models t.\matchrow(r_i)$. In this case,
          $\denote{t.\apply()}^\sigma\,\pkt = \{\pkt\}$. Show that $\denote{t.\apply()[\sigma]}\,\pkt = \{\}\pkt\}$.

          First observe that every $i \in \{1, \ldots, n\}$, we have
          $\denote{\assume t.\matchrow(r_i)}\,\pkt = \emptyset$, so conclude
          that
          \[ \forall i \in \{1,\ldots,n\}.\denote{
          \begin{array}{l}
            \assume \bigwedge_{j=1}^{i-1}\neg t.\matchrow(r_j)\\
            t.\action[\sigma(t)[i]](r_i.\data)
        \end{array}}\,\pkt = \emptyset
          \]

          Finally $\denote{\assume \bigwedge_{i=1}^n \neg
            t.\matchrow(r_i)}\,\pkt = \{\pkt\}$, and $\denote{\SKIP}\,\pkt
          =\{\pkt\}$, so conclude that $\denote{\assume \bigwedge_{i=1}^n \neg
            t.\matchrow(r_i);\SKIP}\,\pkt = \{\pkt\}$.
          Conclude that $\denote{t.\apply()[\sigma]}\pkt = \{pkt\}$.
      \end{enumerate}
  \end{enumerate}
\end{proof}




\subsection{Instrumenting Tables}

The next step is to define a source to source translation that eliminates tables
in the absence of concrete table state, which we will write $c\instr \in \Cmd$.
This is the first step towards the goal of constraining control plane behavior.
Want the instrumented program $c\instr$ to fail in exactly the same situations that
$c\instr$ does, however $c\instr$ is constrained to have no table applications.
The only remaining mechanism is to use $\assume$ and $\assert$ statements to
inspect $\sigma$. We define $c[?]$ in Figure~\ref{fig:table-instrument}.

For simplicity, We're going to assume that all actions in a given table have the
same number of action data fields, and each field is the same number of bits.
This can be realized manually.

We augment the headers for a program $c$ with ghost headers $\gamma_t$ for each
table $t \in \tables(c)$. The header $\gamma_t$ has defined fields
$\reach$, which is set to true if the packet reaches table $t$,
$\hit$ which is set to true the packet hits in the table, and
$\reads$ which is really a list of $|t.\keys|$ variables that stores the
values of the packet when evaluating $t.\keys$.

\begin{figure}[htp]
  %% \begin{minipage}[t]{0.5\textwidth}
  %% \[\begin{array}{r >{\triangleq}cl}
  %% \multicolumn{3}{l}{(\cdot)\instr : \Cmd \to \Cmd} \\
  %% (h.f := e)\instr && h.f := e \\
  %% (\assume b)\instr && b \\
  %% (\assert b)\instr && \assert b\\
  %% (c_1;c_2)\instr && c_1\instr;c_2\instr\\
  %% (c_1 \choice c_2)\instr && c_1\instr \choice c_2\instr\\
  %% (\{c\})\instr && \{c\instr\}\\
  %% (t.\apply())\instr && \\
  %% \multicolumn{3}{r}{
  %%   \qquad
  %%   \begin{array}[t]{l} \displaystyle
  %%     \{ \\
  %%     \quad \havoc \rho;\\
  %%     \quad \assume \rho \in t; \\
  %%     \quad \assume \rho.\matches = t.\keys; \\
  %%     \quad \displaystyle \bigchoice_{i=0}^{|t.\action| -1}
  %%     \left(\begin{array}{l}
  %%       \assume \rho.\action = i;\\
  %%       t.\action[i](\rho.\data)
  %%     \end{array}\right)\\
  %%     \} \choice ( \\
  %%     \quad \assume \forall \rho. \rho \in t \Rightarrow \rho.\matches \neq t.\keys;\\
  %%     \quad \SKIP \\
  %%     )
  %%   \end{array}}
  %% \end{array}
  %% \]
  %% \end{minipage}\begin{minipage}[t]{0.45\textwidth}
\[\begin{array}{r >{\triangleq}cl}
  \multicolumn{3}{l}{(\cdot)\instr : \Cmd \to \Cmd} \\
  (h.f := e)\instr && h.f := e \\
  (\assume b)\instr && \assume b \\
  (\assert b)\instr && \assert b\\
  (c_1;c_2)\instr && c_1\instr;c_2\instr\\
  (c_1 \choice c_2)\instr && c_1\instr \choice c_2\instr\\
  (t.\apply())\instr &&\\
  \multicolumn{3}{l}{
    \qquad
    \begin{array}[t]{l} \displaystyle
      \assume t.\matchrow(\rho_t); \\
      \assume \gamma_t.\keys = t.\keys; \\
    \displaystyle \bigchoice_{i=0}^{|t.\action| -1}
    \left(\begin{array}{l}
      \assume \gamma_t.\miss = 0;\\
      \assume \rho_t.\action = i;\\
      \assume \gamma_t.\hitAction = \rho_t.\id;\\
      t.\action[i](\rho_t.\data)
    \end{array}\right)\\
    \choice (\assume \gamma_t.\miss = 1; \SKIP)  \\
  \end{array}}
  \end{array}
  \]
  \caption{Symbolic Table Instrumentation. For simplicity, we
    assume each action in a table has the same number (and types) of parameters}
  \label{fig:table-instrument}
\end{figure}

\begin{figure}[htp]
  \[\begin{array}{r cl}
  \multicolumn{3}{l}{\state\sigma^t \in \BExpr} \\
  \state\sigma^t & \triangleq &
  \left(\begin{array}{>{\displaystyle}l}
  \gamma_t.\miss = 1 \Leftrightarrow \gamma_t.\hitAction > |\sigma(t.\id)| \\
  \wedge \bigvee_{r_i \in \sigma(t.\id)} \rho = r_i  \\
  \wedge \bigwedge_{r_i \in \sigma(t.\id)} \gamma_t.\hitAction = i \Leftrightarrow \rho_t = r_i \\
  \wedge \bigwedge_{r_i \in \sigma(t.\id)} \left(\gamma_t.\hitAction \geq i \Leftrightarrow \bigwedge_{j=0}^{i-1} \neg t.\matchrow(r_j)[\gamma_t.\keys/t.\keys]\right)\\
  \end{array}\right)\\\\

  \multicolumn{3}{l}{\state\sigma_T \in \BExpr} \\
  \state\sigma_T &\triangleq
  & \displaystyle\bigwedge_{ t \in T } \state\sigma^t
  \end{array}
  \]
  \caption{Symbolic State Encoding. Where $T \subseteq \Table$. We write
    $\state\sigma_c$ where $c \in \Cmd$ as shorthand for $\state\sigma_{\tables(c)}$.}
  \label{fig:table-instrument}
\end{figure}

\begin{lemma}[Symbolic State Distributes]
  \label{lem:sigma-distrib}
  For $\sigma : \Value \to \Row^*$, $T,T_1,T_2 \subseteq \Table$ such that $T = T_1 \subseteq T_2$,
  $\state\sigma_{T} \Leftrightarrow \state{\sigma}_{T_1}\wedge\state{\sigma}_{T_2}$
\end{lemma}

\begin{proof}
  Let $\sigma$, $T$, $T_1$, $T_2$ be given as above. Assume $T = T_1 \subseteq T_2$.
  Compute:
  \[\state\sigma_T\Leftrightarrow
  \left(\bigwedge_{t \in T} \state\sigma^t\right) \Leftrightarrow
  \left(\bigwedge_{t \in T_1 \cup T_2} \state\sigma^t\right) \Leftrightarrow
  \left(\bigwedge_{t \in T_1} \state\sigma^t \wedge \bigwedge_{t \in T_2}\state\sigma^t \right) \Leftrightarrow
  \state\sigma_{T_1} \wedge \state\sigma_{T_2}
  \]

\end{proof}


\begin{lemma}[Symbolic State distributes over Sequence]
  \label{lem:sigma-distrib-seq}
  For $\sigma : \Value \to \Row^*$, $c_1,c_2 \in \Cmd$,
  $\state\sigma_{c_1;c_2} \Leftrightarrow \state{\sigma}_{c_1}\wedge\state{\sigma}_{c_2}$
\end{lemma}

\begin{proof}
  By Lemma~\ref{lem:sigma-distrib} since $\tables(c_1;c_2) = \tables(c_1) \cup \tables(c_2)$.
\end{proof}

\begin{lemma}[Symbolic State Distributes Over Choice]
  \label{lem:sigma-distrib-choice}
  For $\sigma : \Value \to \Row^*$, $c_1,c_2 \in \Cmd$,
  $\state\sigma_{c_1 \choice c_2} \Leftrightarrow \state{\sigma}_{c_1}\wedge\state{\sigma}_{c_2}$
\end{lemma}

\begin{proof}
  By Lemma~\ref{lem:sigma-distrib} since $\tables(c_1;c_2) = \tables(c_1) \cup \tables(c_2)$.
\end{proof}


\begin{samepage}
\begin{theorem}[Instrumentation Equivalence]
  \label{thm:instr-equiv}
  Given a set of variables $V \subseteq \Var$ that contains no ghost variables
  or symbolic variables. For every well-formed $c \in \Cmd$ such that $\fvs(c) \subseteq V$,
  well-formed state $\sigma : \Value \to \Row^*$, and packet $\pkt \in \Pkt$,
  where $T \supseteq \tables(c)$, $R \supseteq \{\rho_t \mid t \in T\}$, and $G \supseteq \{\gamma_t \mid t \in
  T\}$,

  \[\denote{c}^\sigma\,\pkt =_V \denote{\havoc {R \cup G}; \assume{\state\sigma}_T; c\instr}\,\pkt  \]
\end{theorem}
\end{samepage}

\begin{proof}
  Proceed by induction on $c$.
  \begin{enumerate}[align=left]
  \item[$(c = x:=e)$] Immediate, since $R = \emptyset = G$, $\assume{\state\sigma}_{x:=e} = \TRUE$, and $(x:=e)\instr = (x:=e)$.
  \item[$(c = \havoc x)$] \textit{sim}.
  \item[$(c = \assume b)$] \textit{sim}.
  \item[$(c = \assert b)$] \textit{sim}.
  \item[$(c = c_1;c_2)$] Note that well-formedness\todo{define well formedness as single-use tables} implies $\tables(c_1) \cap
    \tables(c_2) = \emptyset$. Let $T_2 = \tables(c_2)$ and $T_1 = T \setminus
    T_2$. Let $R_2 = \{\rho_t.* \mid t \in T_2\}$ and $R_1 = R \setminus R_2$.
    Let $G_2 = \{\rho_t.* \mid t \in T_2\}$ and $G_1 = G \setminus G_2$. Compute
    as follows:
    \[\begin{array}{ll}
    \denote{\havoc {R \cup G}; \assume{\state\sigma_{T}};(c_1;c_2)\instr}\,\pkt
    & \\
    = \denote{\havoc{R\cup G}; \assume{\state\sigma_{T}}; c_1\instr;c_2\instr}\,\pkt
    & \text{definition of }(\cdot)\instr \\
    = \denote{\havoc{R\cup G}; \assume{\state\sigma_{T_1}};\assume{\state\sigma_{T_2}};c_1\instr;c_2\instr}\,\pkt
    & \text{By Lemmas~\ref{lem:sigma-distrib-seq} \&~\ref{lem:assume-currying}} \\
    = \denote{\havoc{R_1 \cup G_1}; \havoc{R_2 \cup G_2}; \assume{\state\sigma_{T_1}};\assume{\state\sigma_{T_2}};c_1\instr;c_2\instr}\,\pkt
    & \text{By definition } \\
    = \denote{\havoc{R_1\cup G_1}; \havoc{R_2 \cup G_2}; \assume{\state\sigma_{T_1}};c_1\instr;\assume{\state\sigma_{T_2}};c_2\instr}\,\pkt
    & \text{By Lemma~\ref{lem:disj-comm} and } \tables(c_1) \cap \tables(c_2) = \emptyset \\
    = \denote{(\havoc{R_1 \cup G_1}; \assume{\state\sigma_{T_1}};c_1\instr);
      (\havoc{R_2 \cup G_2};\assume{\state\sigma_{T_2}};c_2\instr)}\,\pkt
    & \text{By Lemma~\ref{lem:disj-comm} and } \tables(c_1) \cap \tables(c_2) = \emptyset\\
    = \denote{\havoc{R_2 \cup G_2};\assume{\state\sigma_{T_2}};c_2\instr}^\dagger
    \left(\denote{\havoc{R_1 \cup G_1}; \assume{\state\sigma_{T_1}};c_1\instr}\,\pkt\right)
    & \text{by definition} \\
    =_V {\denote{c_2}^\sigma}^\dagger \left(\denote{\havoc{R_1 \cup G_1}; \assume{\state\sigma_{T_1}};c_1\instr}\,\pkt\right)
    & \text{by IH}(c_2) \text{ since } \fvs(c_2) \subseteq \fvs(c_1;c_2) \subseteq V \\
    =_V {\denote{c_2}^\sigma}^\dagger \left({\denote{c_1}^\sigma}^\dagger\pkt\right)
    & \text{by IH}(c_1) \text{ since } \fvs(c_1) \subseteq \fvs(c_1;c_2) \subseteq V \\
    = \denote{c_1;c_2}^\sigma\pkt
    & \text{by definition of }\denote{-}^\sigma\\
    \end{array}\]

    The result follows by Lemma~\ref{lem:equal-proj}.

  \item[$(c = c_1\choice c_2)$]
    \[\begin{array}{ll}
    \denote{\havoc{R \cup G};\assume{\state\sigma_{T}}; (c_1 \choice c_2)\instr}\,\pkt
    & \\
    = \denote{\havoc{R \cup G};\assume{\state\sigma_{T}}; (c_1\instr \choice c_2\instr)}\,\pkt
    & \text{by definition of }(\cdot)\instr\\
    %% = \denote{\havoc{R \cup G};\assume{\state\sigma_{T_1} \wedge \state\sigma_{T_2}}; (c_1\instr \choice c_2\instr)}\,\pkt
    %% & \text{By Lemma~\ref{lem:sigma-distrib-choice}}\\
    %% = \denote{\havoc{R \cup G};\assume{\state\sigma_{T_1}}; \assume{\state\sigma_{T_2}}; (c_1\instr  \choice   c_2\instr)}\,\pkt
    %% & \text{By Lemma~\ref{lem:assume-currying}}\\
    = \denote{\havoc{R \cup G};\assume{\state\sigma_{T}}; c_1\instr
      \choice \havoc{R \cup G};\assume{\state\sigma_{T}}; c_2\instr}\,\pkt
    & \text{By Lemma~\ref{lem:prod-sum}} \\
    %% = \denote{\havoc{R \cup G}; \assume{\state\sigma_{T_1}}; c_1\instr
    %%   \choice \havoc{R \cup G}; \assume{\state\sigma_{T_2}}; c_2\instr}\,\pkt
    %% & \text{BY UNUSED-VARIABLES -> TRIVIAL ASSUMPTIONS LEMMA} \\
    %% =_V \denote{\havoc{R_1 \cup G_1}; \assume{\state\sigma_{c_1}}; c_1\instr
    %%   \choice \havoc{R_2 \cup G_2}; \assume{\state\sigma_{c_2}}; c_2\instr}\,\pkt
    %% & \text{BY UNUSEDVARIABLE HAVOC ELIMINATION LEMMA } \\
    = \denote{\havoc{R \cup G}; \assume{\state\sigma_{T}}; c_1\instr}\,\pkt
    \cup \denote{\havoc{R \cup G}; \assume{\state\sigma_{T}}; c_2\instr}\,\pkt
    & \text{by definition of }\denote{\cdot} \\
    =_V \denote{c_1}^\sigma\pkt \cup \denote{\havoc{R \cup G}; \assume{\state\sigma_{T}}; c_2\instr}\,\pkt
    & \text{By IH}(c_1) \text{ since } \fvs(c_1) \subseteq \fvs(c_1 \choice c_2) \subseteq V, \tables(c_1) \subseteq T \\
    =_V \denote{c_1}^\sigma\pkt \cup \denote{c_2}^\sigma\pkt
    & \text{By IH}(c_2) \text{ since } \fvs(c_2) \subseteq \fvs(c_1 \choice c_2) \subseteq V, \tables(c_2) \subseteq T \\
    = \denote{c_1 \choice c_2}^\sigma\pkt
    & \text{by definition of }\denote{\cdot}^\sigma
    \end{array}
    \]

    The result follows by Lemma~\ref{lem:equal-proj}.

  \item[$(c = t.\apply())$] Let $\pkt$ and $\sigma$ be arbitrary. Let
    $[r_1,\ldots, r_n] = \sigma(t)$.

    Let $P = \{\pkt\{\rho_t.* \mapsto
      v\}\{\gamma_t.* \mapsto v' \mid v,v' \in \Value\} \}$.
      Compute as follows:

      \[\begin{array}{lcl}
      \denote{\havoc R \cup G; \assume {\state\sigma_{t.\apply()}}; t.\apply\instr}\,\pkt
      & \\
      = \denote{\assume {\state\sigma_{t.\apply()}}; t.\apply()\instr}^\dagger P
      & \text{by definition of }\denote{\cdot}^\sigma \\
      = \denote{t.\apply()\instr}^\dagger \{\pkt \mid \pkt \in P, \pkt \models \state\sigma_{t.\apply()} \}
      & \text{by definition of }\denote{\cdot}^\sigma \\
      = \denote{  \begin{array}{l} \displaystyle
          \assume \gamma_t.\keys = t.\keys; \\
          \displaystyle \bigchoice_{a=0}^{|t.\action| -1}
          \left(\begin{array}{l}
            \assume t.\matchrow(\rho_t); \\
            \assume \gamma_t.\miss = 0;\\
            \assume \rho_t.\action = a;\\
            \assume \gamma_t.\hitAction = \rho_t.\id;\\
            t.\action[a](\rho_t.\data)
          \end{array}\right) \\
          \choice (\assume \gamma_t.\miss = 1;\SKIP) \\
      \end{array}}
      \{\pkt \mid \pkt \in P, \pkt \models \state\sigma_{t.\apply()} \}
      & \text{by definition of }(\cdot)\instr \\
      = \displaystyle\bigcup_{a=0}^{|t.\action| - 1}
      \denote{t.\action[a](\rho_t.\data)}
      \left\{\pkt \in P\,\, \begin{array}{|ll}
        \pkt \models \state\sigma_{t.\apply()}, & \pkt \models t.\matchrow(\rho_t)\\
        \pkt \models \gamma_t.\keys = t.\keys, & \pkt \models \rho_t.\action = a \\
        \multicolumn{2}{|l}{\pkt \models \gamma_t.\hitAction = \rho_t.\id}
      \end{array}\right\}
      & \text{by definition of }\denote{\cdot}\\
      \qquad \cup\,\,\{\pkt \in P \mid \pkt \models \state\sigma_{t.\apply()} \wedge \gamma_t.\keys = t.\keys \wedge \gamma_t.\miss = 1 \}
      \end{array}\]

       There are two cases, corresponding to hit and miss. Let $M$ be the `miss
       set' i.e.
       \[M \triangleq \{\pkt \in P \mid \pkt \models \state\sigma_{t.\apply()} \wedge \gamma_t.\keys = t.\keys \wedge \gamma_t.\miss = 1 \},\]

       and let $H_a$ be the input `hit-set' for action $a$, i.e.
      \[ H_a \triangleq \left\{\pkt \in P\,\, \begin{array}{|ll}
        \pkt \models \state\sigma_{t.\apply()}, & \pkt \models t.\matchrow(\rho_t)\\
        \pkt \models \gamma_t.\keys = t.\keys, & \pkt \models \rho_t.\action = a \\
        \multicolumn{2}{|l}{\pkt \models \gamma_t.\hitAction = \rho_t.\id}
      \end{array}\right\}\]

    \begin{enumerate}
    \item[\textit{Case 1}.] Assume that there is some $1 \leq i \leq n$ such
      that $\pkt \models t.\matchrow(r_i)$. In fact, assume that $i$ is the
      smallest such $i$. Then, by definition, $\denote{t.\apply()}^\sigma\,\pkt
      = \denote{t.\action[r_i.\action](r_i.\data)}^\sigma\,\pkt$. Show that
      $M \cup \bigcup_{a=0}^{|t.\action|-1}\denote{t.\action[a](\rho_t.\data)} H_a$ is $V$-equal to this set.

      Show that $M = \emptyset$, by showing that the refinement is contradictory.

      Assume $\state\sigma_{t.\apply()}$, $\gamma_t.\keys = t.\keys$ and
      $\gamma_t.\miss = 1$. First expand the definition of
      $\state\sigma_{t.\apply()}$, which gives us $\gamma_t.\miss = 1
      \Leftrightarrow \gamma_t.\hitAction > n$, $\bigvee_{i}^n \rho = r_i$,
      $\bigwedge_{i=1}^n \gamma_t.\hitAction = i \Leftrightarrow \rho_t = r_i$,
      and

      \[\bigwedge_{i=1}^n \left(\gamma_t.\hitAction \geq i \Leftrightarrow \bigwedge_{j=0}^{i-1}\neg t.\matchrow(r_j)[\gamma_t.\keys/t.\keys]\right)\]

      Since we know $\gamma_t.\keys = t.\keys$, we can equivalently write
      \[\bigwedge_{i=1}^n \left(\gamma_t.\hitAction \geq i \Leftrightarrow \bigwedge_{j=0}^{i-1}\neg t.\matchrow(r_j)\right)\]

      Since $\gamma_t.\miss = 1$ we know that $\gamma_t.\hitAction > n$, which
      means that for all $1 \leq j \leq n$, $\neg t.\matchrow(r_j)$, which
      contradicts the assumption that $t.\matchrow(r_j)$. Thus the refinement is
      contradictory and $M = \emptyset$. \hfill \checkmark

      Now, show that $\forall \pkt \in H_a. \rho_t = r_i$, by showing that the
      refinement implies that $\rho_t = r_i \wedge \bigwedge_{j \neq i}\rho_t \neq r_j$. We assume the following facts:
      \[ \state\sigma_{t.\apply()} \wedge \gamma_t = t.\keys \wedge \gamma.\hitAction = \rho_t.\id \wedge t.\matchrow(\rho_t) \wedge
      \rho_t.\action = a\]

      By unfolding the definition of $\state\sigma_{t.\apply()}$, we also know that
      $\gamma.\miss = 1 \Leftrightarrow \gamma_t.\hitAction > n$, $\bigvee_{i=1}^n \rho = r_i$, $\bigwedge_{i=1}^n \gamma_t.\hitAction = i \Rightarrow \rho_t = r_i$, and
      \[\bigwedge_{i=1}^n \left( \gamma_t.\hitAction \geq i \Leftrightarrow \bigwedge_{j=0}^{i-1}\neg t.\matchrow(r_j)[\gamma_t.\keys/t.\keys] \right)\]

      As before, since $\gamma_t.\keys = t.\keys$ we can write this as
      \[\bigwedge_{i=1}^n \left( \gamma_t.\hitAction \geq i \Leftrightarrow \bigwedge_{j=0}^{i-1}\neg t.\matchrow(r_j)\right)\]

      By assumption, we know that $t.\matchrow(r_i)$, and for $1 \leq j < i$,
      $\neg t.\matchrow(r_j)$. Combining this with the above fact gives
      $\gamma_t.\hitAction = i$. Then since $\bigwedge_{i=1}^n
      \gamma_t.\hitAction = i \Leftrightarrow \rho_t = r_i$,
      conclude $\rho_t = r_i \wedge \bigwedge_{i\neq j} \rho_t\neq r_i$. \hfill \checkmark

      Now, we can write
      \[\bigcup_{a=0}^{|t.\action| - 1}\denote{t.\action[a](\rho_t.\data)}^\dagger H_a
       = \denote{t.\action[r_i.\action](r_i.\data)}^\dagger H_{r_i.\action}
       \]

       which is $V$-equivalent to
       $\denote{t.\action[r_i.\action](r_i.\data)}\,\pkt$ by
       Lemma~\ref{lem:proj-den-comm}. The result follows by the IH on
       $t.\action[r_i.\action](r_i.\data)$ and Lemma~\ref{lem:equal-proj}.

     \item[\text{Case 2}.]Assume that there is no $1 \leq i \leq n$ such that
       $\pkt \models t.\matchrow(r_i)$. Then, by definition,
       $\denote{t.\apply()}^\sigma\,\pkt = \{\pkt\}$. Show that
       $M \cup\bigcup_{a=0}^{|t.\action|-1}\denote{t.\action[a](\rho_t.\data)} H_a$ is $V$-equal to this $\{\pkt\}$.

        Let $\pkt' \in P$ such that $\pkt' \models \state\sigma_{t.\apply}$,
        $\pkt' \models \gamma_t.\keys$, and $\gamma_t.\miss =1$. Expanding the
        definition of $\state\sigma_{t.\apply()}$ further we get that $\pkt'
        \models \gamma_t.\miss = 1 \Leftrightarrow \gamma_t.\hitAction > n$, forall $0
        \leq i \leq n$, $\pkt' \models \gamma_t.\hitAction = i \Leftrightarrow
        \rho_t = r_i$, and $\pkt' \models \gamma_t.\hitAction \geq i \Leftrightarrow
        \bigwedge_{j=1}^{i-1} \neg.\matchrow(r_j)$ (since $\pkt' \models
        \gamma_t.\keys = t.\keys$).

        Our assumption gives us that $\bigwedge_{j=1}^n \neg t.\matchrow(r_j)$,
        which means that $\gamma_t.\hitAction > n$, and that $\gamma_t.\miss =
        1$. Conclude that $H_a = \emptyset$ and $M \neq \emptyset$. Since
        $\emptyset \neq M \subseteq P =_V \{\pkt\}$, $M =_V \{\pkt\}$ by
        Lemma~\ref{lem:subset-proj}. The result follows by
        Lemma~\ref{lem:equal-proj}.
    \end{enumerate}

  \end{enumerate}
\end{proof}

\subsection{Generation of Verification Conditions}

Now, we would like to be able to translate the result from
Theorem~\ref{thm:instr-equiv} into a symbolic representation. To do this, we'll
use the weakest precondition, defined in Figure~\ref{fig:wp}

\begin{figure}[H]
  \[
  \begin{array}{r >{\triangleq}c l}
    \WP(h.f := e, b)
    && b[e/h.f] \\
    \WP(\havoc x, b)
    && \forall x.\,b \\
    \WP(\assert b_a, b)
    && b_a \wedge b \\
    \WP(\assume b_a, b)
    && b_a \Rightarrow b \\
    \WP(t.\apply,b) && \textrm{\textcolor{red}{undefined}} \\
    \WP(c_1;c_2, b)
    && \WP(c_1,\WP(c_2,b)) \\
    \WP(c_1 \choice c_2, b)
    && \WP(c_1,b) \wedge \WP(c_2,b)
  \end{array}
  \]
  \caption{Dijkstra's weakest precondition function}
  \label{fig:wp}
\end{figure}

Now, we need to relate states $\sigma$ and the computed $\WP(c\instr,\TRUE)$.
Note that since there are no havocs introduced in $c\instr$, all symbolic rows
$\rho$, and header values $h.f$ are unbound.

\begin{theorem}[VC Correctness]
  \label{thm:vc-correct}
  Given a set of variables $V$, for every well-formed $c \in \Cmd$ such that $\fvs(c) = V$,
  and $\sigma \in \State$, the following formula is valid:
  \[ \forall V. \WP(c[\sigma], \TRUE) \iff \forall V. (\forall R. \forall G. \state\sigma_c \Rightarrow  \WP(c\instr,\TRUE)\]
  where $R = \{\rho_t.* \mid t \in \tables(c)\}$ and $G = \{\gamma_t.*\mid t \in \tables (c)\}$.
\end{theorem}

\begin{proof}
  Let $V$, $c$, and $\sigma$ be given as above.
  Theorem~\ref{thm:instr-equiv} gives the equivalence
  \[\forall \pkt. \denote{c}^\sigma\,\pkt =_{\fvs(c)} \denote{\havoc{R \cup G}; \assume{\state\sigma_c}; c\instr}\,\pkt\]

  By Theorem~\ref{thm:subst}, we get

  \[\forall \pkt.\denote{c[\sigma]}\,\pkt =_{\fvs(c)}  \denote{\havoc{R \cup G}; \assume{\state\sigma_c}; c\instr}\,\pkt\]

  By Dijkstra, we can see

  \[\forall V. \WP(c[\sigma], \TRUE) \iff \forall V. \WP(\havoc{R \cup G}; \assume{\state\sigma_c}; c\instr, \TRUE))\]

  By definition of $\WP$, this is equivalent to

  \[ \forall V. \WP(c[\sigma],\TRUE) \iff \forall V. \left(\forall R.\forall G.\state\sigma_c \Rightarrow \WP(c\instr, \TRUE)\right)\]

\end{proof}


\clearpage
\section{The Research Problem}

Now we can formally define the research problems that we want to solve. We have
an ideal, that is probably not solvable in general. First we begin by defining a control plane formula.

\begin{definition}[Control Plane Formulae ]
  A control plane formula $\varphi$ is a boolean expression in $\BExpr$ that
  contains no header accesses $h.f$.
\end{definition}

\begin{quote}
  \textbf{Inference Problem.} Given a command $c \in \Cmd$, compute (the
  weakest) control plane formula $\varphi$ such that if, for a state $\sigma :
  \Value \to \Row^*$, the following formula is valid \[\state\sigma_c
  \Rightarrow \varphi,\] then \[\forall \pkt \in \Pkt.~ \denote{c}^\sigma\pkt \neq \error \]
\end{quote}

However, this $\varphi$ may be $\FALSE$ for many realistic programs $c$, so we may
prefer to solve the following problem:

\begin{quote}
  \textbf{Repair Problem.} Given a command $c \in \Cmd$, compute (the weakest)
  control plane formula $\varphi$, and a test $b$ such that for every
  packet $\pkt \in \Pkt$ and state $\sigma : \Value \to \Row^*$, if the
  following formula is valid
  \[\state\sigma_c \Rightarrow \varphi,\]
  then \[\denote{\assume b; c}^\sigma\pkt \neq \error \]
\end{quote}

\section{Abduction}

We can observe that \textbf{Inference} is simply solvable by reduction to
Quantifier Elimination (QE). In fact, QE is one of the key driving forces of the
Dilligs' abduction work (\textsc{Hola}, \textsc{Explain}). We sketch the
argument here.

In the following we assume a terminating function $\qe : \Var \times \BExpr \to
\BExpr$ such that for $V \in \Var$ and $b \in \BExpr$, $\bfvs(\qe(V,b)) \cap V =
\emptyset$ and $\qe(V,b) \Leftrightarrow \forall V. b$.

\begin{lemma}[Universal Quantifier Weakness]
  \label{lem:quantified-weakest}
  For $b \in \BExpr$ and $V \subseteq \Var$, $\forall V. b$ is the weakest
  formula on variables $\Var \setminus V$ that implies $b$.
\end{lemma}
\begin{proof}
  Let $b$ and $V$ be given. Assume there is some $b' \Rightarrow b$ such that
  $\bfvs(b') \subseteq \Var \setminus V$. Show that $b' \Rightarrow \forall
  V.b$.

  \[\begin{array}{rll}
   1. & b' \Rightarrow b & \textit{assumption} \\
   2. & b' & \textit{Assumption} \\
   3. & V & \textit{arbitrary} \\
   4. & b & \textit{modus ponens (1,2)} \\
   5. & \forall V.b & \forall\textit{-intro (3-4)}\\
   6. & b' \Rightarrow \forall V. b & \Rightarrow\textit{-intro (2-5)}
  \end{array}\]


\end{proof}

\begin{theorem}[Quantifer Elimination]
  For $D \subseteq \Var$ a set of dataplane variables and $C \subseteq \Var$ a
  set of control plane variables such that $D \cap C = \emptyset$, for every well-formed
  command $c \in \Cmd$ such that $\fvs(c) \subseteq D$, the formula $\qe(D,
  \WP(c\instr, \TRUE))$ is a solution to the \textbf{Inference Problem}.
\end{theorem}

\begin{proof}
  Let $D$, $C$, and $c$ be given as above. Let $R \subseteq C$ be the set of
  symbolic row variables in $c\instr$, and let $G \subseteq C$ be the set of
  ghost variables in $c\instr$. Notice that $\fvs(c\instr) = \fvs(c) \cup G \cup
  R$. Let $\varphi = \qe(D,\WP(c\instr, \TRUE))$. Since
  $\bfvs(\WP(c\instr,\TRUE)) \subseteq \fvs(c\instr)$, and $\bfvs(\varphi) \cap
  D = \emptyset$, we know that $\varphi$ is a control plane formula.

  Now, let $\sigma$ be such that $\state\sigma_c \Rightarrow \varphi$ is valid,
  i.e. $\forall R. \forall G. \state\sigma_c \Rightarrow \varphi$ is valid. By
  assumption about $\qe$, this is equivalent to $\forall R.\forall G.
  \state\sigma_c \Rightarrow \forall D. \WP(c\instr, \TRUE)$. Since
  $\bfvs(\state\sigma_c) \cap D = \emptyset$, we can equivalently write $\forall
  D. \forall R. \forall G. \state\sigma_c \Rightarrow \WP(c\instr,\TRUE)$. By
  Theorem~\ref{thm:vc-correct}, $\forall D. \WP(c[\sigma],\TRUE)$ is valid. By Dijkstra,
  $\forall \pkt \in \Pkt. \denote{c[\sigma]} \neq \error$. Conclude $\forall
  \pkt \in \Pkt. \denote{c}^\sigma \neq \error$, by Theorem~\ref{thm:subst}.

  Now, by Theorem~\ref{thm:vc-correct} it suffices to show that $\varphi$ is the
  weakest control plane formula stronger than $\WP(c[?], \TRUE)$. By
  Lemma~\ref{lem:quantified-weakest}, $\forall D. \WP(c\instr, \TRUE)$ is the
  weakest condition on variables $C$ that is still stronger than
  $\WP(c\instr,\TRUE)$. Since $\varphi \Leftrightarrow \forall D. \WP(c\instr,
  \TRUE)$, $\varphi$ is the weakest condition stronger than $\WP(c\instr,\TRUE)$.

\end{proof}





\clearpage
\section{Data-Driven Precondition Inference?}


It seems that a solution to our problem can also be found in work by
Padhi/Sharma/Millstein entitled \textit{Data-Driven Precondition Inference with
  Learned Features}\todo{This won't make a ton of sense unless you've
  read this paper}. Their algorithm uses a subroutine,
$\textsc{VPreGen}(c,Q,G)$, which takes code $c$, a boolean predicate $Q$,
and a set of passing test inputs $G$ and produces a predicate $P$ such that
$P(t) = \TRUE$ for all $t \in G$, and $\{P\}\,C\,\{Q\}$.

This gets us most of the way there. Naively, let's consider the space of inputs
to be $\State \times \Pkt$. Then let $b_P$ be a boolean expression such that
$b_p = \textsc{VPreGen}(c\instr,\TRUE,\emptyset)$. Then we know $b_P \Rightarrow
\WP(c\instr,\TRUE)$. However, $b_p$ is not \emph{a priori} a control-plane
formula.

There's a trivial fix: modify the feature learning algorithm to only generate
features that are control-plane formulae. The procedure $\textsc{FeatureLearn}$
generates features from a space of operations described by the procedure
$\textsc{GetOperations}()$. If we simply restrict \textsc{GetOperations} so that
it only returns features that are control-plane formulae, then the generated
expression $b_p$ is guaranteed to be a control plane formula. It may also be
prudent to restrict the input space $G$ to be a subset of $\State$, rather than
of $\State \times \Pkt$, but it doesn't seem strictly necessary.


\paragraph{Discussion} This doesn't quite achieve our goal, because the
synthesized solution is not necessarily the weakest. Further, its not clear to
what extent this procedure relies on a non-empty set of examples $G$. Nor is it
immediately clear where we would get such inputs. Currently each iteration of
the \textsc{VPreGen} algorithm augments the set of examples with a failing
example -- if it turns out that good inputs are necessary, it could be augmented
with a similar solver call to generate a positive example (e.g.
$\textsc{Sat}(\WP(c\instr,\TRUE))$).

\paragraph{Relation to \texttt{bf4}}  \texttt{bf4} algorithm is similar to
\textsc{VPreGen}, using formulae rather than examples. Rather than learn features, \texttt{bf4} uses a static set of
control-plane features (which they call ``atoms''). Then, rather than learn a
candidate boolean expression by abstracting these atoms and using a set of
concrete positive and negative examples, \texttt{bf4} uses Z3's unsat-core to
refine its candidate solution. Finally, \texttt{bf4} is interested in
bug-finding rather than verification so it computes necessary conditions rather
than sufficient conditions. The following table summarizes the differences

\begin{center}
\begin{tabular}{lll}
  \toprule
  & $\textsc{VPreGen}(c,Q,G)$ & \texttt{bf4's} $\textsc{INFER}(G,B,\mathcal P)$ \\
  \midrule \\
  Solution ($\varphi$)
  & $\{\varphi\} C \{Q\}$, and $\forall t \in G.\,\varphi(t)$
  & $G \models \phi$, minimizing(?) $|\{\eta\mid B
  \wedge \varphi\}|$ \\[1.5em]
  Features
  & dynamically learns features
  & features (aka \emph{atoms}) are heuristically defined ($\mathcal P$) \\[1.5em]
  Candidates &
  \begin{tabular}{>{\!\!\!}l}
    abstracts features; \\
    learns boolean expression; \\
    concretizes features
  \end{tabular}
  & iteratively negates Z3's unsat-core\\
  \bottomrule
\end{tabular}
\end{center}

\section{Can we use templates?}

One option is to use a kind of constrained template-based synthesis, where we
generate a catalogue of templates based on syntactic features of the target table.

For example, given a single table like the following:

\[t = \{\keys: [h.f]; \actions: [\lambda x.~~h.g:= x]\}\]

and the simple program \[t.\apply()\]

We may be able to generate a boolean template constructed from the following
comparisons

\[
\begin{array}{l}
  \rho.\keys[i]~\square_{\{=,\neq\}}~?_{v_3} \Rightarrow \rho.\data[i]~\square_{\{=,\neq\}}~?_{v_4} \\

  \rho.\keys[i]~\square_{\{=,\neq\}}\rho.\data[i]
\end{array}\]

where $[b]?$ indicates a hole to either use template $b$ or replace it with
$\TRUE$, $\square_S$ indicates a template for an operation, where $S$ is the set
of allowed operations, and $?_{v_i}$ indicates a hole that should evaluate to an element
of $\Value$.



Now we may wonder: \emph{can we procedurally generate templates in a (nearly) complete way}?

To do so, we need to extend our templates along the following dimensions:
\begin{enumerate}[align=left]
\item[\textit{Keys}.] Should generalize by changing the LHS comparisons to $
  \bigwedge_i[\rho.\keys[i]~\square_{\{=,\neq\}}~?_{v_i}]?$
\item[\textit{Action Data}.] Should generalize by changing the RHS comparisons to $\bigwedge_i[\rho.\data[i]~\square_{\{=,\neq\}}~?_{v_i}]?$
\item[\textbf{Actions}.] We need to generalize the template across multiple actions. This should be as simple as adding $\rho.\action = i$ on the RHS of each implication above.
\item[\textit{Sequence}.] I'm not sure how to generalize sequentially composed tables.
  Perhaps a larger catalogue of templates conditioned on structural information:
  if we notice that $t_1$ has a dataflow path to the keys of $t_2$, we should
  generate a join condition template, otherwise we may be able to simply ``and'' the templates.

\item[\textit{Nondeterminism} ($c_1 \choice c_2$).] To solve the
  \textbf{Inference Problem} we simply `and' the templates together, but to solve
  the \textbf{Repair Problem} we may be able to constrain the problem (by
  constraining the packets) to either $c_1$ or $c_2$. This would require
  computing a $b_{\textit{pkt}}$.
\end{enumerate}

\end{document}
