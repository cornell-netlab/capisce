\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{halloweenmath}
\usepackage{amsmath, amssymb, amsthm, array, stmaryrd}
\usepackage{wasysym}
\usepackage{booktabs}
\usepackage{todonotes}
\usepackage{float}
\usepackage{scalerel}
%% \usepackage[notext,not1,nomath]{stix}
\usepackage{enumitem}

\title{Notes on Control Plane Inference}
\author{Eric Campbell}


% semantics
\newcommand{\pkt}{\mathit{pkt}}
\newcommand{\error}{\mathsf{error}}
\newcommand{\denote}[1]{\left\llbracket#1\right\rrbracket}
\newcommand{\edenote}[1]{\mathcal{E}\denote{#1}}

%booleans
\newcommand{\TRUE}{\mathsf{tt}}
\newcommand{\FALSE}{\mathsf{ff}}

%% bitvectors
\newcommand{\binop}{\mathbin{\oplus}}
\newcommand{\unop}{\mathop{\text{\pointer}}}

% sets
\newcommand{\Value}{\mathsf{Value}}
\newcommand{\BVExpr}{\mathsf{BVExpr}}
\newcommand{\BExpr}{\mathsf{BExpr}}
\newcommand{\Cmd}{\mathsf{Cmd}}
\newcommand{\Action}{\mathsf{Action}}
\newcommand{\Instr}{\mathsf{Instr}}
\newcommand{\Prog}{\mathsf{Prog}}
\newcommand{\GCL}{\mathsf{GCL}}
\newcommand{\Pkt}{\mathsf{Pkt}}
\newcommand{\Model}{\mathsf{Model}}
\newcommand{\Hdr}{\mathsf{Hdr}}
\newcommand{\Field}{\mathsf{Field}}
\newcommand{\Table}{\mathsf{Table}}
\newcommand{\Row}{\mathsf{Row}}
\newcommand{\List}{\mathsf{List}}
\newcommand{\Var}{\mathsf{Var}}
\newcommand{\SymbRow}{\mathsf{SymbRow}}

% record fields
\newcommand{\matches}{\mathsf{matches}}
\newcommand{\action}{\mathsf{action}}
\newcommand{\actions}{\mathsf{actions}}
\newcommand{\keys}{\mathsf{keys}}
\newcommand{\data}{\mathsf{data}}
\newcommand{\params}{\mathsf{params}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\reach}{\mathit{\mathit{reach}}}
\newcommand{\hit}{\mathit{hit}}
\newcommand{\reads}{\mathit{reads}}


% commands
\newcommand{\assert}{\mathop{\mathsf{assert}}}
\newcommand{\assume}{\mathop{\mathsf{assume}}}
\newcommand{\apply}{\mathsf{apply}}
\newcommand{\choiceop}{\rotatebox[origin=c]{90}{$\sqsubset\!\!\!\sqsupset$}}
\newcommand{\choice}{\mathbin{\choiceop}}
\DeclareMathOperator*{\bigchoice}{\scalerel*{\choiceop}{\sum}}
\newcommand{\havoc}[1]{\mathop{\textsf{havoc}}#1}
\newcommand{\SKIP}{\mathsf{skip}}

% math
\newcommand{\argmin}{\mathop{\textrm{argmin}}}
\newcommand{\WP}{\textit{wp}}
\newcommand{\satisfy}[3]{({#1,#3}) \models_{#2}}
\newcommand{\notsatisfy}[3]{({#1,#3})\not\models_{#2}}
\newcommand{\nondet}{\mathsf{nondet}}
\newcommand{\ghostly}{\mathsf{ghostly}}
\newcommand{\state}[1]{\llparenthesis#1\rrparenthesis}
\newcommand{\instr}{[\forall]}
\newcommand{\ginstr}{[\mathghost]}

% defined functions
\newcommand{\tables}{\mathop{\mathsf{tables}}}

% Theorems
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}

\begin{document}

\maketitle

\section{Preliminaries}

\subsection{Syntax}

\begin{figure}[htp]
  \[\begin{array}{lclll}
    \multicolumn{3}{l}{\Value} \\
    v & ::= & [n]_w  & \textit{Bitvector Literal} & (a,g,p,\iota) \\
    \multicolumn{3}{l}{\SymbRow} \\
    \rho & ::= & \left\{
    \begin{array}{l}
      \matches = \List[x];\\
      \action = x;\\
      \data = \List[x]
    \end{array}\right\} & \textit{Symbolic Row} & (\iota)\\
    \multicolumn{3}{l}{\BVExpr} \\
    e & ::= & v & \textit{Value} & (a,g,p,\iota)\\
      & \mid & h.f & \textit{Header Access} & (a,g,p,\iota)\\
      & \mid & \rho.\matches[i] & \textit{Symbolic Match} & (\iota)\\
      & \mid & \rho.\action & \textit{Symbolic Action} & (\iota) \\
      & \mid & \rho.\data[i] & \textit{Symbolic Action Data} & (\iota) \\
      & \mid & x & \textit{Action Data Variable} & (a^*) \\
      & \mid & e \binop e & \textit{Arbitrary Binary Operation} & (a,g,p,\iota) \\
    & \mid & \unop e & \textit{Arbitrary Unary Operation} & (a,g,p,\iota) \\
    \multicolumn{3}{l}{\Table} \\
    t & ::= & \left\{\begin{array}{l}
    t.\id = v; \\
    t.\keys = \List[h.f]; \\
    t.\actions = \List[\lambda \vec x.\,a]\\
    \end{array}\right\} & \textit{Table} & (p)\\
    \multicolumn{3}{l}{\BExpr} \\
    b & ::= & \FALSE  & \textit{Absurdity}& (a,g,p,\iota)\\
      & \mid & b \Rightarrow b & \textit{Implication} & (a,g,p,\iota)\\
    & \mid & e = e & \textit{Bitvector Equality} & (a,g,p,\iota)\\
    & \mid & \rho \in t & \textit{Table membership} & (\iota)\\
    & \mid & \forall \rho.~b & \textit{Row Universality} & (\iota)\\
    \multicolumn{4}{l}{c \in \Cmd, a \in \Action, g \in \GCL, p \in \Prog, \iota \in \Instr } \\
    c & ::=  & h.f := e & \textit{Assignment} & (g,p,\iota) \\
      & \mid & \havoc \rho & \textit{Row Havoc} & (\iota) \\
      & \mid & \assert b & \textit{Assertion} & (g,p,\iota)\\
      & \mid & \assume b & \textit{Assumption} & (g,p,\iota) \\
      & \mid & t.\apply() & \textit{Table Application} & (p)\\
      & \mid & c;c & \textit{Sequential Composition} & (a,g,p,\iota) \\
      & \mid & c \choice c & \textit{Nondeterministic Choice} & (g,p,\iota)\\
      & \mid & \{c\} & \textit{Scope} & (g,p,\iota)\\
    \multicolumn{3}{l}{
      \begin{array}{ll}
        x \in \Var & h \in \Hdr\\
        n,w,i \in \mathbb{N} & f \in \Field
    \end{array}} & \textit{Sets }\\
  \end{array}
\]
\caption{Grammar of Commands $c \in \Cmd$. Legal action indicated by $a \in
  \Action$, legal instrumented command variants indicated by $\iota \in \Instr$,
  dataplane programs indicated by $p \in \Prog$, and table-free commands
  indicated by $g \in \GCL$.}
\label{fig:grammar}
\end{figure}

The following sections describe aspects of the grammar shown in Figure~\ref{fig:grammar}.

\paragraph{Packets}
Our dataplane programs will reason about structured representations of packets,
that is, they will be transformations on sets of packet headers. In programs,
packet headers $h \in \Hdr$ are essentially structs with fields $f \in
\Field$. Write $h.f$ for a header $h$ and a field $f$ is the value $v$ of $f$
in header $h$.

\paragraph{Tables}
A table $t \in \Table$ is a record with a few fields described below:
\begin{enumerate}[align=left]
  \item[($t.\id$)] A table's unique identifier. A well-formed program can only have
    one occurence of each table identifier.
  \item[($t.\keys$)] A list of header field accesses indicating the match keys.
  \item[($t.\actions$)] A list of actions that can be executed. An action is a lambda
    expression $\lambda \vec x. c$ where the variables $x$ are in scope for the
    commands $c$, which $c$ are straight-line code only (see below).
\end{enumerate}
For now we assume that the default action is the no-operation command (see
$\SKIP$ below). We use $|l|$ to indicate the number of elements in a list or vector $l$
such as $t.\keys$ or $t.\actions$.


\paragraph{Symbolic Table Rows}
A symbolic table row $\rho \in \SymbRow$ represents a symbolic row. Like tables,
rows are also records with the following fields \todo{Well formedness constraint?}
\begin{enumerate}[align=left]
  \item[($\rho.\matches$)] A list variable of length representing the possible match keys.
  \item[($\rho.\action$)] A variable representing the action choice
  \item[($\rho.\data$)] A list variable representing the possible action data
\end{enumerate}

To represent the $i$th match variable in $\rho$, use standard list
access notation: $\rho.\matches[i]$.

Note that symbolic table rows are only meant to be used in the instrumentation
stage and not by a programmer.

\paragraph{Values}
Values $v \in \BVExpr$ are bitvector literals, written $[n]_w$, where $n$
is a natural value and $w$ is the width. We say that $[n]_w = [m]_l$ is
undefined if $w \neq l$, and otherwise is true iff $n \equiv m \mod 2^w$.

\paragraph{Bitvector Expressions}
Bitvector expressions $e \in \BVExpr$ can be values $v$, header accesses $h.f$,
symbolic row variables, variables $x$, or any
(currently unspecified) binary or unary bitvector operation.

\paragraph{Boolean Expressions}
Boolean expressions $b \in \BExpr$ can be $\FALSE$, implication ($b_1
\Rightarrow b_2$), equality of bitvector expressions ($e_1 = e_2$ for two
bitvector expressions $e_1$ and $e_2$), or universal quantification $\forall
\rho \in t. b$, where $\rho$ is a symbolic row in table $t$. Note that universal
quantification is meant to only be used by the instrumentation mechanism and not
a programmer.

We can represent other standard boolean operators by using standard encodings:
\[\begin{array}{l}
  \TRUE \triangleq \TRUE \Rightarrow \TRUE \\
  \neg b \triangleq b \Rightarrow \FALSE \\
  b_1 \vee b_2 \triangleq \neg b_1 \Rightarrow b_2 \\
  b_1 \wedge b_2 \triangleq \neg(\neg b_1 \vee \neg b_2) \\
  \vec e = \vec e' \triangleq \bigwedge_i e_i = e'_i
\end{array}\]

\paragraph{Commands}
Data plane programs $c \in \mathsf{Cmd}$ can be assignments ($h.f := e$),
assumptions ($\assume b$), assertions ($\assert b$), table application
($t.\apply()$), sequential composition ($c_1;c_2$ for two commands $c_1$ and $c_2$), and
nondeterministic choice ($c_1 \choice c_2$ for two commands $c_1$ and $c_2$).

We define $\SKIP$ as the following syntactic sugar $\assume \TRUE$.

We express a collection of invariants on commands as subsets of the set $\Cmd$.
It is convenient to describe these as subgrammars. First, action-commands $a \in
\Action$ contain only non-symbolic assignment and sequence. If an action
command has variables, indicated by the starred variant $a*$, it is called
\emph{open}, if it has none it is called \emph{closed}.

Second, $p \in \Prog \subset \Cmd$ represents the expected set of programs extracted from a
P4 interface, most notably, it contains tables $t$ and no symbolic selection
statements or symbolic expersions.

Conversely $\iota \in \Instr \subset \Cmd$ represents a program instrumented
with symbolic variables. A program $\iota$ cannot apply tables using
$t.\apply()$, but instead uses havoc statements, to
introduce symbolic variables $\rho$ in $c$.

Finally $g \in \GCL \subset \Prog \subset \Cmd$ represents the core algebraic
flavor of GCL without havoc, symbolic tables, or table application.


Define $\tables(c) \subset \Table$ to be the set of all tables that occur in $c$.

\subsection{Semantics}

First we describe the semantic objects packet and state before giving semantics
to bitvector expressions, boolean expressions, and commands.

\paragraph{Packets}
A packet $\pkt$ is a map from header fields to values. Use the syntax $\pkt[h.f
  \mapsto v]$ to represent the packet that is equivalent to $\pkt$ on all header
fields except $h.f$, which maps to $v$.

\paragraph{State}
On-switch state is represented by a mapping from tables identifiers $t.\id$ to
lists of rows $[r_1,\ldots,r_n] \in \Row(t)^*$.

A similar to a symbolic row $\rho$, a concrete row $r$ comprises a list of match
values $r.\matches$, an action identifier $r.\action$, and a list of action data
$r.\data$. A concrete row $r$ is in the set $\Row(t)$ if it is well formed for a
table $t$ iff the following conditions hold:
\begin{enumerate}
\item $|r.\matches| = |t.\keys|$
\item $r.\action < |t.\actions|$
\item $|r.\data| = |\vec x|$ where $\lambda \vec x. c = t.\actions[r.\action]$
\end{enumerate}\

A state map $\sigma : \Value \to \Row^*$ is well-formed for a command $c$ iff the
following conditions hold:
\begin{enumerate}
\item[\textsc{WellFormedRows}] For every $t\in \tables(c)$, every row in $\sigma(t.\id)$ is well-formed.
\item[\textsc{NoShadow}] For every $t \in \tables(c)$, with $r_1,\ldots,r_n =
  \sigma(t.\id)$, for every $1 \leq i \leq n$, there does not exist $1 \leq j <
  i$ such that $r_i.\matches = r_j.\matches$.
\end{enumerate}
\paragraph{Row Models}
We also need models $\mu \in \Model$ to indicate which symbolic rows corresponds
to which concrete rows, i.e. $\Model = \SymbRow \rightharpoonup \Row$. We write
$\mu\{\rho \mapsto r\}$ to extend $\mu$ by mapping $\rho$ to $r$, and write $\mu
\setminus \rho$, to remove $\rho$ from the map.

\paragraph{Expressions}
The semantics of expressions is shown in Figure~\label{fig:sem-expr}. Note that
here we implicitly use the strict semantics for definedness, that is, operators
only succeed when all of their arguments are defined, otherwise it returns
undefined.

\begin{figure}[H]
  \[\begin{array}{l>{\triangleq}cl}
  \multicolumn{3}{l}{\edenote{e} : \Model \to \Pkt \rightharpoonup \Value }\\
    \edenote{v}~\mu~\pkt &&
    v \\
    \edenote{h.f}~\mu~\pkt &&
    pkt(h.f)\\
    \edenote{\rho.\matches[i]}~\mu~\pkt &&
    \mu(\rho).\matches[i] \\
    \edenote{\rho.\action}~\mu~\pkt &&
    \mu(\rho).\action \\
    \edenote{\rho.\data[i]} &&
    \mu(\rho).\data[i]\\
    \edenote{e_1 \binop e_2}~\mu~\pkt&&
    \edenote{e_1}~\mu~\pkt \binop
    \edenote{e_2}~\mu~\pkt \\
    \edenote{\unop e}~\mu~\pkt &&
    \unop \left(\edenote{e}~\mu~\pkt\right)
  \end{array}
  \]
  \caption{Semantics of Expressions}
  \label{fig:sem-expr}
\end{figure}

\paragraph{Boolean Satisfaction}
The satisfaction relation $\satisfy \sigma \pkt \mu b$ is defined in
Figure~\ref{fig:bool-satis} in terms of the three kinds of variable contexts,
packets, models, and states. We also use the strict semantics here, most
importantly in the equality rule. Sometimes two expressions are considered equal
if they are both undefined; we do not take this approach, considering the
equality undefined if either argument is undefined.

\begin{figure}
  \[\begin{array}{l>{\iff}cl}
  \satisfy \sigma \pkt \mu \FALSE && \textit{pigs fly} \\
  \satisfy \sigma \pkt \mu b_1 \Rightarrow b_2 &&
  \notsatisfy \sigma \pkt \mu  b_1~\textit{or}~
  \satisfy \sigma \pkt \mu b_2\\
  \satisfy \sigma \pkt \mu e_1 = e_2 &&
  \edenote{e_1}~\pkt~\mu = \edenote{e_2}~\pkt~\mu, \qquad
  \text{(note strict semantics)} \\
  \satisfy\sigma\pkt\mu \rho \in t. && \mu(\rho) \in \sigma(t.\id) \\
  \satisfy \sigma \pkt \mu \forall \rho. ~b &&
  \forall r.
  \satisfy \sigma \pkt {\mu\{\rho \mapsto r\}} b
  \end{array}
  \]
  \todo[inline]{Clarify $\error$ states}
  \caption{Satisfaction for $\BExpr$.}
  \label{fig:bool-satis}
\end{figure}

\paragraph{Command Evaluation}
Commands are evaluated similar to Avenir in Figure~\ref{fig:com-sem}. The
notable differences are the inclusion of assertions, the nondeterminism
operators, and a cleaner representation of table application.

\begin{figure}[htp]
  \[\begin{array}{l >{\triangleq}cl}
  \multicolumn{3}{l}{\denote{c}^\sigma : \Model \to \Pkt \to \mathcal{P}(\Model \times \Pkt)_\error }\\
    \denote{h.f := e}^\sigma\,\mu\,\pkt && \{(\mu, \pkt\{h \mapsto v\} \mid v \in \edenote{e}\,\mu\,\pkt\})\} \\
    \denote{\assume b}^\sigma\,\mu\,\pkt &&
    \begin{cases}
      \{(\mu,\pkt)\} & \satisfy \sigma \pkt \mu b \\
      \{\} & \textit{otherwise} \\
    \end{cases}\\
    \denote{\assert b}^\sigma\,\mu\,\pkt &&
    \begin{cases}
      \{(\mu,\pkt)\} & \satisfy \sigma \pkt \mu b \\
      \error & \textit{otherwise}
    \end{cases} \\
    \denote{\havoc \rho}^\sigma\,\mu\,\pkt &&
    \{(\mu\{\rho \mapsto r\}, \pkt) \mid r \in \Row\} \\
    \denote{c_1;c_2}^\sigma\,\mu\,\pkt&&
    \bigcup_{(\mu',\pkt') \in \denote{c_1}^\sigma\,\mu\,\pkt}\denote{c_2}^\sigma\,\mu'\,\pkt' \\
    \denote{c_1 \choice c_2}^\sigma\,\mu\,\pkt &&
    \denote{c_1}^\sigma\,\mu\,\pkt \cup \denote{c_2}^\sigma\,\mu\,\pkt \\
    \denote{\{c\}}^\sigma\,\mu\,\pkt &&
    \{(\mu,\pkt') \mid (\mu',\pkt') \in \denote{c}^\sigma\,\mu\,\pkt \}\\
    \denote{t.\apply()}^\sigma\,\mu\,\pkt &&
    \begin{cases}
      \denote{c[\vec d/\vec x]}^\sigma\,\mu\,\pkt,
      & \text{where}~\lambda \vec x.~c = r.\action, \vec d = r.\data \\
      & \text{where}~r = \argmin_i\{\satisfy \sigma \pkt \mu b_i\} \\
      & \text{where}~b_i = \sigma(t.\id)[i].\matches = t.\keys \\
      \{(\mu,\pkt)\}, & \mathit{otherwise}
    \end{cases}
  \end{array}\]
  \caption{Semantics of Commands}
  \label{fig:com-sem}
\end{figure}

\section{Encoding}

Now we will define a collection of source-to-source translations that deal with
the controller interface.

\subsection{Eliminating Tables}

The first thing to do is to define a source-to-source translation that
eliminates the tables. The observation here is that tables essentially represent
if-else statements, so once we have a state $\sigma$ in hand we can rewrite the
program to a command $c[\sigma] \in \Cmd$ that uses no tables. This translation
is defined in Figure~\ref{fig:table-elim}

\begin{figure}
  \[\begin{array}{r>{\triangleq}cl}
  \multicolumn{3}{l}{(\cdot)[\sigma] : \Cmd \to \Cmd} \\
  \multicolumn{3}{l}{(\cdot)[\sigma] : \Prog \to \GCL} \\
  (h.f := e)[\sigma] && h.f := e   \\
  (\assume b)[\sigma] && \assume b \\
  (\assert b)[\sigma] && \assert b \\
  (c_1;c_2)[\sigma] && c_1[\sigma];c_2[\sigma] \\
  (c_1 \choice c_2)[\sigma] && c_1[\sigma] \choice c_2[\sigma] \\
  (\{c\})[\sigma] && \{c[\sigma]\} \\
  (t.\apply())[\sigma] &&
  \begin{array}[t]{l}
    (\\
    \quad \assume {r_1.\matches = t.\keys};\\
    \quad t.\action[r_1.\action](r_1.\data)\\
    )~\choice\\
    \phantom)~\,\vdots\\
    \phantom)\,\choice~(\\
    \quad \assume {r_n.\matches = t.\keys};\\
    \quad t.\action[r_n.\action](r_n.\data)\\
    )\choice (\\
    \quad \displaystyle \assume {\bigwedge_{i=1}^n r_n.\matches \neq t.\keys};\\
    \quad \SKIP \\
    )\\
    \textrm{where}~[r_1;\ldots;r_n] = \sigma(t.\id)
  \end{array}
  \end{array}
  \]
  \caption{Table Substitution}
  \label{fig:table-elim}
\end{figure}


\begin{theorem}[Table Substitution]
  For every $c \in \Cmd$, well-formed state $\sigma : \Value \to \Row^*$, model
  $\mu \in \Model$, and packet $\pkt \in \Pkt$, then for any state $\tau :
  \Value \to \Row^*$,
  \[\denote{c}^\sigma~\mu~\pkt = \denote{c[\sigma]}^\tau~\mu~\pkt\]
\end{theorem}
\begin{proof}
\todo[inline]{By induction on the structure of $c$.}
\end{proof}


\subsection{Instrumenting Tables}

The next step is to define a source to source translation that eliminates tables
in the absence of concrete table state, which we will write $c[?] \in \Cmd$.
This is the first step towards the goal of constraining control plane behavior.
Want the instrumented program $c[?]$ to fail on exactly the same situations that
$c[\sigma]$ does, however $c[?]$ is constrained to have no table applications.
The only remaining mechanism is to use $\assume$ and $\assert$ statements to
inspect $\sigma$. We define $c[?]$ in Figure~\ref{fig:table-instrument}.

For simplicity, We're going to assume that all actions in a given table have the
same number of action data fields, and each field is the same number of bits.
This can be realized manually.

We augment the headers for a program $c$ with ghost headers $\gamma_t$ for each
table $t \in \tables(c)$. The header $\gamma_t$ has defined fields
$\reach$, which is set to true if the packet reaches table $t$,
$\hit$ which is set to true the packet hits in the table, and
$\reads$ which is really a list of $|t.\keys|$ variables that stores the
values of the packet when evaluating $t.\keys$.

\begin{figure}[htp]
  \begin{minipage}[t]{0.5\textwidth}
  \[\begin{array}{r >{\triangleq}cl}
  \multicolumn{3}{l}{(\cdot)\instr : \Cmd \to \Cmd} \\
  (h.f := e)\instr && h.f := e \\
  (\assume b)\instr && b \\
  (\assert b)\instr && \assert b\\
  (c_1;c_2)\instr && c_1\instr;c_2\instr\\
  (c_1 \choice c_2)\instr && c_1\instr \choice c_2\instr\\
  (\{c\})\instr && \{c\instr\}\\
  (t.\apply())\instr && \\
  \multicolumn{3}{r}{
    \qquad
    \begin{array}[t]{l} \displaystyle
      \{ \\
      \quad \havoc \rho;\\
      \quad \assume \rho \in t; \\
      \quad \assume \rho.\matches = t.\keys; \\
      \quad \displaystyle \bigchoice_{i=0}^{|t.\action| -1}
      \left(\begin{array}{l}
        \assume \rho.\action = i;\\
        t.\action[i](\rho.\data)
      \end{array}\right)\\
      \} \choice ( \\
      \quad \assume \forall \rho. \rho \in t \Rightarrow \rho.\matches \neq t.\keys;\\
      \quad \SKIP \\
      )
    \end{array}}
  \end{array}
  \]
  \end{minipage}\begin{minipage}[t]{0.45\textwidth}
\[\begin{array}{r >{\triangleq}cl}
  \multicolumn{3}{l}{(\cdot)\ginstr : \Cmd \to \Cmd} \\
  (h.f := e)\ginstr && h.f := e \\
  (\assume b)\ginstr && \assume b \\
  (\assert b)\ginstr && \assert b\\
  (c_1;c_2)\ginstr && c_1\ginstr;c_2\ginstr\\
  (c_1 \choice c_2)\ginstr && c_1\ginstr \choice c_2\ginstr\\
  (\{c\})\ginstr && \{c\ginstr\}\\
  (t.\apply())\ginstr &&\\
  \multicolumn{3}{l}{
    \qquad
    \begin{array}[t]{l} \displaystyle
    \gamma_t.\reach := [1]_1; \\
    \gamma_t.\reads := t.\keys; \\
    (\\
    \quad \assume \rho.\matches = t.\keys; \\
    \quad \gamma_t.\hit := [1]_1; \\
    \quad \displaystyle \bigchoice_{i=0}^{|t.\action| -1}
    \left(\begin{array}{l}
    \assume \rho.\action = i;\\
    t.\action[i](\rho.\data)
    \end{array}\right)\\
    ) \choice ( \\
    \quad \assume \rho.\matches \neq t.\keys; \\
    \quad \gamma_t.\hit := [0]_1;\\
    \quad \SKIP \\
    )
  \end{array}}
  \end{array}
  \]
  \end{minipage}
  \caption{Symbolic Table instrumentation alternatives. For simplicity, we
    assume each action in a table has the same number (and types) of parameters.
    We want to eliminate the universal quantifier in the miss case shown in
    pn the left. The current attempt, on the right, uses a ghost header
    $\gamma_t$ for every table $t$. }
  \label{fig:table-instrument}
\end{figure}

\begin{figure}[htp]
  \[\begin{array}{r cl}
  \multicolumn{3}{l}{\state\sigma_c : (\Value \to \Row^*) \to \BExpr} \\
  \state\sigma_c &\triangleq
  & \displaystyle\bigwedge_{ t \in \tables(c) }
  \begin{array}{l}
  \left(\bigvee_{r_i \in \sigma(t.\id)}
  \rho = r_i\right) \wedge \\
  \left(\bigwedge_{r_i \in \sigma(t.\id)}
  \gamma_t.\mathit{reads} \neq r_i.\keys\right)
  \Rightarrow \gamma_t.\mathit{hit} = [0]_1
  \end{array}
  \end{array}
  \]
  \caption{Symbolic State Encoding}
  \label{fig:table-instrument}
\end{figure}

\begin{samepage}
\begin{theorem}[Ghostly Instrumentation Equivalence]
  \label{thm:ghost-instr-equiv}
  For every $c \in \Cmd$, well-formed state $\sigma : \Value \to \Row^*$, model
  $\mu \in \Model$, and packet $\pkt \in \Pkt$, \[\denote{c}^\sigma~\mu~\pkt = \denote{c\ginstr;\assume \state\sigma_c}^\sigma~\mu~\pkt.\]
\end{theorem}
\end{samepage}

\begin{samepage}
\begin{theorem}[Quantified Instrumentation Equivalence]
  \label{thm:forall-instr-equiv}
  For every $c \in \Cmd$, well-formed state $\sigma : \Value \to \Row^*$, model
  $\mu \in \Model$, and packet $\pkt \in \Pkt$, \[\denote{c}^\sigma~\mu~\pkt = \denote{c\instr}^\sigma~\mu~\pkt.\]
\end{theorem}
\end{samepage}

\begin{proof}
  \todo[inline]{Proceed by induction on the structure of $c$, leaving $\sigma$, $\mu$, $\pkt$ general}


\end{proof}




\subsection{Computing Logical Forms}

Now, we would like to be able to translate the result from
Theorems~\ref{thm:ghost-instr-equiv} and~\ref{thm:forall-instr-equiv} into a
symbolic representation. To do this, we'll use the weakest precondition, defined
in Figure~\ref{fig:wp}

\begin{figure}[H]
  \[
  \begin{array}{r >{\triangleq}c l}
    \WP(h.f := e, b)
    && b[e/h.f] \\
    \WP(\havoc \rho, b)
    && \forall \rho.\,b \\
    \WP(\assert b_a, b)
    && b_a \wedge b \\
    \WP(\assume b_a, b)
    && b_a \Rightarrow b \\
    \WP(t.\apply,b) && \textrm{\textcolor{red}{undefined}} \\
    \WP(c_1;c_2, b)
    && \WP(c_1,\WP(c_2,b)) \\
    \WP(c_1 \choice c_2, b)
    && \WP(c_1,b) \wedge \WP(c_2,b)
  \end{array}
  \]
  \caption{Dijkstra's weakest precondition function}
  \label{fig:wp}
\end{figure}

\subsection{A Strange Example}

Now we'll present a counterexample showing that even though the
$\forall$-free instrumentation $c\ginstr$ described in
Figure~\ref{fig:table-instrument} is sufficient to prove
Theorem~\ref{thm:ghost-instr-equiv}, it doesn't produce correct preconditions.

\begin{samepage}
Consider the following example table:
\[t = \{\id = 47; \keys = [h.z]; \action = [\lambda x.\,h.x := x] \}\]

and the following command
\[c = h.x := 4; t.\apply(); \assert h.x \neq h.z\]
\end{samepage}

\subsubsection{Instrumentation}

Now we must instrument this program. The resulting programs for both $c\ginstr$ and $c\instr$ are shown in Figure~\ref{fig:ex-instr}

\begin{figure}[H]
  \begin{minipage}[t]{0.5\textwidth}
    \[
    \begin{array}{l}
      \multicolumn 1 c {\boxed{c\instr}} \\
      h.x := 4; \\
      \{\\
      \quad \havoc \rho; \\
      \quad \assume \rho \in t; \\
      \quad \assume \rho.\matches[0] = h.z; \\
      \quad \assume \action = 0; \\
      \quad h.x := \rho.\data[0]; \\
      \}\choice ( \\
      \quad \assume \forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z;\\
      \quad \SKIP
      )\\
      \assert h.x \neq h.z
    \end{array}
    \]
  \end{minipage} \begin{minipage}[t]{0.48\textwidth}
    \[\begin{array}{l}
    \multicolumn 1 c {\boxed{c\ginstr}} \\
    h.x := 4;\\
    \gamma_t.\reach := [1]_1;\\
    \gamma_t.\reads[0] := [h.z]\\
    (\\
    \quad \assume \rho.\matches[0] = h.z; \\
    \quad \gamma_t.\hit := [1]_1; \\
    \quad \assume \rho.\action = 0;\\
    \quad h.x := \rho.\data[0];\\
    ) \choice (\\
    \quad \assume \rho.\matches \neq t.\keys; \\
    \quad \gamma.\hit := [0]_1; \\
    \quad \SKIP \\
    );\\
    \assert h.x \neq h.z \\
    \end{array}
    \]
  \end{minipage}
  \caption{The left program is the forall instrumentation of program $c$, the
    right one uses a ghost header. }
  \label{fig:ex-instr}
\end{figure}


\subsubsection{Predicate Transformer}
Now, we compute the predicate semantics for $c\ginstr$, which we will conclude is:

\[\WP(c[?],\TRUE) =\rho.\action = 0 \Rightarrow
\begin{array}{l}
  \rho.\matches[0] = h.z \Rightarrow \rho.\data[0] \neq h.z\;\wedge \\
  \rho.\matches[0] \neq h.z \Rightarrow 4 \neq h.z
  \end{array}
\]

The derivation is in Section~\ref{sec:example-ghost-wp-derivation}. The problem is
that the following state $\sigma$ triggers no assertion violations in the execution, but does violate the specification:

\[\sigma = \left\{ 47 \mapsto \begin{array}{l}
  [\{\keys = [4]; \action = 0;\data = [3]\}\\
  \phantom[  \{\keys = [3]; \action = 0; \data = [4]\}
  ]
\end{array}
\right\} \]

First, let's see that $\sigma$ does not trigger an assertion violation. Consider
the program $c[\sigma]$ below, and let $\pkt \in \Pkt$ be arbitary:

\[
\begin{array}{l}
  h.x := 4; (\\
  \quad (\assume h.z = 4; h.x := 3)\;\choice \\
  \quad (\assume h.z = 3; h.x := 4)\;\choice \\
  \quad (\assume h.z \neq 4; \assume h.z \neq 3; \SKIP) \\
  ); \\
  \assert h.x \neq h.z
\end{array}
\]

There are three cases.
\begin{enumerate}
  \item If $\pkt(h.z) = 4$, then when it reaches the assert statement, $\pkt(h.x) =
    3$, so $h.x \neq h.z$ is true.
  \item If $\pkt(h.z) = 3$, then when it reaches the assert statement $\pkt(h.x) = 4$, so $h.x \neq h.z$ is true.
  \item If $\pkt(h.z) \neq 3$ and $\pkt(h.z) \neq 4$, then by the time the
    packet reaches the assert statement $\pkt(h.x) = 4$, and $h.x \neq h.z$ is
    true because $\pkt(h.x) = 4 \neq \pkt(h.z)$.
\end{enumerate}

So we know that $\sigma$ should be allowed by the condition $\WP(c[?],\TRUE)$ for all packets. However the following $\mu$ and $pkt$ demonstrate the falsity of the condition:
\[\mu = \{\rho \mapsto \sigma(t.\id)[1]\}
\quad
\pkt = \{h \mapsto \{z \mapsto 4, x\mapsto 0\}\} \]

\[\begin{array}{l}
\satisfy\sigma\pkt\mu \left(\rho.\action = 0 \Rightarrow
\begin{array}{l}
  \rho.\matches[0] = h.z \Rightarrow \rho.\data[0] \neq h.z\;\wedge \\
  \rho.\matches[0] \neq h.z \Rightarrow 4 \neq h.z
\end{array}\right)\\
\iff\\
\satisfy\sigma\pkt\mu  0 = 0 \Rightarrow
\begin{array}{l}
  (3 = 4 \Rightarrow 3 \neq 4) \wedge
  (3 \neq 4 \Rightarrow 4 \neq 4)
\end{array} \\
\iff \\
\satisfy\sigma\pkt\mu \TRUE \Rightarrow
\begin{array}{l}
  (\FALSE \Rightarrow \TRUE)\wedge (\FALSE \Rightarrow \FALSE)
\end{array} \\
\iff\\
\satisfy\sigma\pkt\mu \FALSE \\
\iff \\
\textit{pigs fly}
\end{array}
\]

\noindent which demonstrates that $\sigma$ is disallowed by $\WP(c\ginstr,\TRUE)$.

This problem does not arise using the instrumentation $c\instr$. In this case,
the  weakest precondition is (see Section~\ref{sec:example-forall-wp-derivation} for a derivation)
\[
\WP(c\instr,\TRUE) =
\begin{array}{rl}
&(\forall \rho.\; \rho \in t \wedge \rho.\matches[0] = h.z \wedge \rho.\action = 0
\Rightarrow h.z \neq \rho.\data[0])\\
\wedge
& (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4 \neq h.z
\end{array}
\]
\noindent which is satisfied by this example:

\[
\begin{array}{l}
  \satisfy\sigma\pkt\mu
  \begin{array}{rl}
    &(\forall \rho.\; \rho \in t \wedge \rho.\matches[0] = h.z \wedge \rho.\action = 0
    \Rightarrow h.z \neq \rho.\data[0])\\

    &\wedge (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4  \neq h.z
  \end{array} \\
  \iff \\
  \begin{array}{rl}
    &\satisfy\sigma\pkt\mu \forall \rho.\; \rho \in t \wedge \rho.\matches[0] = h.z \wedge \rho.\action = 0
    \Rightarrow h.z \neq \rho.\data[0]\\
    \mathit{and}
    &\satisfy\sigma\pkt\mu (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4  \neq h.z
  \end{array} \\
  \iff\\
  \begin{array}{rl}
    &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[0]\}} \rho.\matches[0] = h.z \wedge \rho.\action = 0
    \Rightarrow h.z \neq \rho.\data[0]\\
    \mathit{and}
  &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[1]\}} \rho.\matches[0] = h.z \wedge   \rho.\action = 0
    \Rightarrow h.z \neq \rho.\data[0]\\
    \mathit{and}
    &\satisfy\sigma\pkt\mu (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4  \neq h.z
  \end{array} \\
  \iff \\
  \begin{array}{rl}
    &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[0]\}} 4 = 4 \wedge 0 = 0
    \Rightarrow 4 \neq 3\\
    \mathit{and}
  &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[1]\}} 3 = 4 \wedge \rho.\action = 0
    \Rightarrow 4 \neq 4\\
    \mathit{and}
    &\satisfy\sigma\pkt\mu (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4  \neq h.z
  \end{array} \\
  \iff \\
  \begin{array}{rl}
    &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[0]\}}\TRUE \\
    \mathit{and}
  &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[1]\}} \TRUE
    \Rightarrow 4 \neq 4\\
    \mathit{and}
    &\satisfy\sigma\pkt\mu (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4  \neq h.z
  \end{array} \\
  \iff \\
  \begin{array}{rl}
    &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[0]\}}\TRUE \\
    \mathit{and}
  &\satisfy\sigma\pkt{\mu\{\rho \mapsto \sigma(47)[1]\}} \TRUE \\
    \mathit{and}
    &\satisfy\sigma\pkt\mu (\forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z) \Rightarrow 4  \neq h.z
  \end{array} \\
  \iff \\
  \begin{array}{rl}
    &\notsatisfy\sigma\pkt\mu \forall \rho.\;\rho \in t \Rightarrow\rho.\matches[0] \neq h.z \\
    \mathit{or}
    & \satisfy\sigma\pkt\mu ( 4  \neq h.z)
  \end{array}\\
  \iff\\
  \begin{array}{rl}
    &\notsatisfy\sigma\pkt{\mu\{\rho\mapsto\sigma(47)[0]\}} \rho.\matches[0] \neq h.z \\
    \mathit{or}
    &\notsatisfy\sigma\pkt{\mu\{\rho\mapsto\sigma(47)[1]\}} \rho.\matches[0] \neq h.z \\
    \mathit{or}
    & \satisfy\sigma\pkt\mu ( 4  \neq h.z)
  \end{array}\\
  \iff \\
  \begin{array}{rll}
    &\satisfy\sigma\pkt{\mu\{\rho\mapsto\sigma(47)[0]\}} 3 = 4  & \times \\
    \mathit{or}
    &\satisfy\sigma\pkt{\mu\{\rho\mapsto\sigma(47)[1]\}} 4 = 4 & \checkmark\\
    \mathit{or}
    & \satisfy\sigma\pkt\mu (4 \neq 4) & \times
  \end{array}\\
  \end{array}
\]

\subsubsection{Analysis}

The problem with the ghostly instrumentation, $c\ginstr$, is that it allows for
packets to execute the default action of a table $t$ whenever \emph{any} row in
$\sigma(t.\id)$ is missed.

So why we can prove Theorem~\ref{thm:ghost-instr-equiv}? We
leverage the condition $\state\sigma_c$, which has two parts. The first, shown
below, constrains the symbolic rows $\rho$ for a specific table $t$ to only
refer to the rows that are in $\sigma(t.\id)$. In the universally-quantified
version $c\instr$, this condition is realized symbolically using the constraints
$\rho \in t$.
\[ \bigwedge_{t \in \tables(c)} \bigvee_{r_i \in \sigma(t.\id)} \rho_t = r_i\]
Concretely, for our example this is
\[ \rho = \{\keys = [4]; \action = 0;\data = [3]\}\vee \rho = \{\keys = [3]; \action = 0; \data = [4]\} \]

The second part of $\state\sigma_c$ ensures that the default action is only
executed when the packet misses in the table. Shown below, this subformula plays
the role of the $\forall \rho$ assumption at the start of the default action in
$c\instr$.
\[\bigwedge_{t \in \tables(c)} \left(\bigwedge_{r_i \in \sigma(t.\id)} \gamma_t.\reads = r_i.\matches\right) \Rightarrow \gamma_t.\hit = [0]_1 \]

In our example this is
\[(\gamma_t.\reads[0] \neq 3 \wedge \gamma_t.\reads[0] \neq 4) \Rightarrow \gamma_t.\hit = [0]_1 \]

So we can prove Theorem~\ref{thm:ghost-instr-equiv}, because the state encoding
$\state\sigma_c$ finitely enumerates the rows of $\sigma$. However, this
information is not maintained in the weakest precondition calculation
$\WP(c\ginstr,\TRUE)$.

Of course it's not, because we've omitted $\state\sigma_c$ from the weakest
precondition calculation! Of course $\WP(c\ginstr,\TRUE)$ isn't going to compute
the precise constraints we want because the precision comes from $\state\sigma_c$.

One solution is tod to generalize $\state\sigma_c$ to a symbolic representation,
but this just gets us back to where we started. The naive generalization of the
$\state\sigma_c$, which we'll write $\state?_c$ is the following:

\[\state?_c \triangleq \bigwedge_{t \in \tables(c)} \rho \in t \wedge
((\forall \rho. \rho \in t \Rightarrow \gamma_t.\reads = \rho.\keys ) \Rightarrow \gamma_t.\hit = [0]_1),\]
\noindent which is the exact same structure provided by $c\instr$, except implemented using ghost state rather than at the table application point.

\textbf{What's the move here?} It seems like instrumenting using $c\instr$ gives
us the VCs we want, and $c\ginstr$ doesn't (yet). This fact is obscured by
Theorem~\ref{thm:ghost-instr-equiv}. I think we want a theorem that describes
the semantic completeness of whatever program we are going to pass into $\WP$,
as Theorem~\ref{thm:forall-instr-equiv} does. The end goal is to compute a sufficiently general formula that can describe all legal control-plane behaviors, perhaps something like Theorem~\ref{thm:instr-expressiveness}:

\begin{theorem}[Instrumentation Expressiveness]
  \label{thm:instr-expressiveness}
  Given an instrumentation strategy $(\cdot)[?] : \Cmd \to \Cmd$.
  For every $c \in \Cmd$, and $\sigma : \Value \to \Row^*$
  \[(\forall \pkt \in \Pkt. \forall \mu \in \Model.~\satisfy\sigma\pkt\mu \WP(c[?], \TRUE)) \iff (\forall \pkt \in \Pkt.\forall \mu \in \Model.~\denote{c}^\sigma\,\mu\,\pkt \neq \error)\]
\end{theorem}

Now, Theorem~\ref{thm:instr-expressiveness} is a corollary of
Theorem~\ref{thm:forall-instr-equiv} and Dijsktra '75, with $[?] = \instr$.
However, its not an immediate corollary of Theorem~\ref{thm:ghost-instr-equiv},
because (I contend) it shows the equivalence of the program
$c\ginstr;\assume\state\sigma_c$ and $c$ not the equivalence of $c\ginstr$ and
$c$.

I see three ways forward. The first is to proceed with $c\instr$. The second is
to come up with an improvement on $c\ginstr$ that properly encodes misses (e.g.
by returning to a previous approach that indexed each row $\rho_0, \rho_1,
\ldots$). The third is to come up with a proper symbolic generalization of state
$\state\sigma_c$.


\subsubsection{WP derivation for Forall Instrumentation}
\label{sec:example-forall-wp-derivation}

\[
\begin{array}{l}
  \WP\left(
  \begin{array}{l}
    h.x := 4; \\
    \{\\
    \quad \havoc \rho; \\
    \quad \assume \rho \in t; \\
    \quad \assume \rho.\matches[0] = h.z; \\
    \quad \assume \action = 0; \\
    \quad h.x := \rho.\data[0]; \\
    \}\choice ( \\
    \quad \assume \forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z;\\
    \quad \SKIP
    )\\
    \assert h.x \neq h.z
  \end{array},
  \TRUE\right) \\
  =\WP\left(
  \begin{array}{l}
    h.x := 4; \\
    \{\\
    \quad \havoc \rho; \\
    \quad \assume \rho \in t; \\
    \quad \assume \rho.\matches[0] = h.z; \\
    \quad \assume \action = 0; \\
    \quad h.x := \rho.\data[0]; \\
    \}\choice ( \\
    \quad \assume \forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z;\\
    \quad \SKIP
    )
  \end{array},
  h.x \neq h.z\right) \\
  =\WP\left(h.x := 4,
  \WP\left(\begin{array}{l}
    \{\\
    \quad \havoc \rho; \\
    \quad \assume \rho \in t; \\
    \quad \assume \rho.\matches[0] = h.z; \\
    \quad \assume \action = 0; \\
    \quad h.x := \rho.\data[0]; \\
    \}\choice ( \\
    \quad \assume \forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z;\\
    \quad \SKIP
    )
  \end{array},
  h.x \neq h.z\right)\right) \\
  =\WP\left(h.x := 4,
  \begin{array}{rl}
    &\WP\left(\begin{array}{l}
    \havoc \rho; \\
    \assume \rho \in t; \\
    \assume \rho.\matches[0] = h.z; \\
    \assume \action = 0; \\
    h.x := \rho.\data[0]
    \end{array}, h.x \neq h.z \right) \\
    \wedge &
    \WP\left(\begin{array}{l}
    \assume \forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z;\\
    \SKIP
    \end{array},
    h.x \neq h.z\right)
  \end{array} \right) \\
  =\WP\left(h.x := 4,
  \begin{array}{rl}
    &(\forall \rho. \rho \in t \wedge \rho.\matches[0] = h.z \wedge \rho.\action = 0 \Rightarrow \rho.\data[0] \neq h.z) \\
    \wedge &
     \left((\forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z)
     \Rightarrow h.x \neq h.z\right)
  \end{array} \right) \\
  =\begin{array}[t]{rl}
    &(\forall \rho. \rho \in t \wedge \rho.\matches[0] = h.z \wedge \rho.\action = 0 \Rightarrow \rho.\data[0] \neq h.z) \\
    \wedge &
     \left((\forall \rho.~\rho \in t \Rightarrow \rho.\matches[0] \neq h.z)
     \Rightarrow 4 \neq h.z\right)
  \end{array} \\
  \end{array}
\]


\subsubsection{WP derivation for Ghostly Instrumentation}
\label{sec:example-ghost-wp-derivation}

\[\begin{array}{l}
  \WP\left(\begin{array}{l}
    h.x := 4;\\
    \gamma_t.\reach := [1]_1;\\
    \gamma_t.\reads[0] := [h.z]\\
    (\\
    \quad \assume \rho.\matches[0] = h.z; \\
    \quad \gamma_t.\hit := [1]_1; \\
    \quad \assume \rho.\action = 0;\\
    \quad h.x := \rho.\data[0];\\
    ) \choice (\\
    \quad \assume \rho.\matches \neq t.\keys; \\
    \quad \gamma.\hit := [0]_1; \\
    \quad \SKIP \\
    );\\
    \assert h.x \neq h.z \\
  \end{array}, \TRUE\right) \\
  =\WP\left(\begin{array}{l}
    h.x := 4;\\
    \gamma_t.\reach := [1]_1;\\
    \gamma_t.\reads[0] := [h.z]\\
    (\\
    \quad \assume \rho.\matches[0] = h.z; \\
    \quad \gamma_t.\hit := [1]_1; \\
    \quad \assume \rho.\action = 0;\\
    \quad h.x := \rho.\data[0];\\
    ) \choice (\\
    \quad \assume \rho.\matches \neq t.\keys; \\
    \quad \gamma.\hit := [0]_1; \\
    \quad \SKIP \\
    );\\
  \end{array},  h.x \neq h.z\right) \\
  =\WP\left(\begin{array}{l}
    h.x := 4;\\
    \gamma_t.\reach := [1]_1;\\
    \gamma_t.\reads[0] := [h.z]\\
  \end{array},
  \WP\left(
  \begin{array}{rl}
    &\WP\left(
    \begin{array}{l}
    \assume \rho.\matches[0] = h.z; \\
    \gamma_t.\hit := [1]_1; \\
    \assume \rho.\action = 0;\\
    h.x := \rho.\data[0]\\
    \end{array}, h.x \neq h.z\right)\\
    \wedge &
    \WP\left(\begin{array}{rl}
    \assume \rho.\matches \neq t.\keys; \\
    \gamma.\hit := [0]_1; \\
    \SKIP \\
    \end{array}, h.x\neq h.z \right)
  \end{array}\right)
  \right) \\
  = \WP\left(\begin{array}{l}
    h.x := 4;\\
    \gamma_t.\reach := [1]_1;\\
    \gamma_t.\reads[0] := [h.z]\\
  \end{array},
  \left(
  \begin{array}{rl}
    &\left(\rho.\matches[0] = h.z \wedge \rho.\action = 0;
    \rho.\data[0] \neq h.z\right)\\
    \wedge &
    \left(\rho.\matches \neq t.\keys \Rightarrow h.x\neq h.z \right)
  \end{array}\right)
  \right) \\
  =
  \begin{array}{rl}
    &\left(\rho.\matches[0] = h.z \wedge \rho.\action = 0;
    \rho.\data[0] \neq h.z\right)\\
    \wedge &
    \left(\rho.\matches \neq t.\keys \Rightarrow 4\neq h.z \right)
  \end{array}
\end{array}\]



\clearpage
\section{The Research Problem}

Now we can formally define the research problems that we want to solve. We have
some ideal goals, that are probably not solvable in general.

\begin{quote}
  \textbf{Conservative Problem.} Given a command $c \in \Cmd$, compute the weakest test
  $b$ such that if a state $\sigma : \Value \to \Row^*$ the following
  judgement is defined and satisfied \[\satisfy\sigma\emptyset\emptyset b,\] then \[\forall \pkt \in \Pkt.~
  \denote{c}^\sigma \pkt \neq \error \]
\end{quote}

However, this $b$ may be $\FALSE$ for many realistic programs $c$, so we may
prefer to solve the following problem:

\begin{quote}
  \textbf{Flexible Problem.} Given a command $c \in \Cmd$, compute a test
  $b_{\mathit{cp}}$, and a test $b_{\mathit{pkt}}$ such that
  for every packet $\pkt \in \Pkt$ such that
  \[\satisfy \emptyset \pkt \emptyset b_{\mathit{pkt}},\]
  and for every state $\sigma : \Value \to \Row^*$ such that
  \[\satisfy \sigma \pkt \emptyset b_{\mathit{cp}},\]
  then \[\denote{c}^\sigma ~\emptyset~\pkt \neq \error \]
\end{quote}



\section{Reduction to QE}

We can observe that the \textbf{Conservative Problem} is simply solvable. We
sketch the argument here.

\begin{conjecture}[Quantifer Elimination]
  The \textbf{\textrm{Conservative Problem}} is reducable to Quantifer Elimination.
\end{conjecture}

\begin{proof}[Proof Sketch.]
  Given a command $c \in \Cmd$. Compute the instrumented command $c[?]$. We know
  it is equivalent to $c$ by Theorem~\ref{thm:instr-equiv}. Then $\forall
  \overrightarrow{h.f}.\WP(c[?],\TRUE)[\overrightarrow{h.f}]$,\todo{how to write this?} is such a
  formula $b$ by Dijkstra '75. To make $b$ a controller formula, then we simply
  need to remove the dataplane variables via a QE procedure.
\end{proof}

This doesn't work in general. Standard QE procedures are exponential at best, and
enumerating all eth/ipv4 src/dst addresses already takes an intractable amount
of time.

\section{Can Templates save us?}

One option is to use a kind of constrained template-based synthesis, where we
generate a catalogue of temaplates based on syntactic features of the target table.

For example, given a single table like the following:

\[t = \{\keys: [h.f]; \actions: [\lambda x.~~h.g:= x]\}\]

and the simple program \[t.\apply()\]

We may be able to generate a template that looks like

\[\begin{array}{>{\displaystyle}c}
  {[\exists \rho \in t.~ \rho.\keys[0]~\square_{\{=,\neq\}}~?_{v_1}\wedge \rho.\data[0]~\square_{\{=,\neq\}}~?_{v_2} ]?} \\
  \wedge\\
  {[\forall \rho \in t.~\rho.\keys[0]~\square_{\{=,\neq\}}~?_{v_3} \Rightarrow \rho.\data[0]~\square_{\{=,\neq\}}~?_{v_4}]?}
\end{array}\]

where $[b]?$ indicates a hole to either use template $b$ or replace it with
$\TRUE$, $\square_S$ indicates a template for an operation, where $S$ is the set
of allowed operations, and $?_{v_i}$ indicates a hole that should evaluate to an element
of $\Value$.

Now we may wonder: \emph{can we procedurally generate templates in a (nearly) complete way}?

To do so, we need to extend our templates along the following dimensions:
\begin{enumerate}[align=left]
\item[\textbf{Keys}.] Should generalize by changing the LHS comparisons to $
  \bigwedge_i[\rho.\keys[i]~\square_{\{=,\neq\}}~?_{v_i}]?$
\item[\textbf{Action Data}.] Should generalize by changing the RHS comparisons to $\bigwedge_i[\rho.\data[i]~\square_{\{=,\neq\}}~?_{v_i}]?$
\item[\textbf{Actions}.] We need to generalize the template across multiple actions. This should be as simple as adding $\rho.\action = i$ on the RHS of each implication above.
\item[\textbf{Sequence}.] I'm not sure how to generalize sequentially composed tables.
  Perhaps a larger catalogue of templates conditioned on structural information:
  if we notice that $t_1$ has a dataflow path to the keys of $t_2$, we should
  generate a join condition template, otherwise we may be able to simply ``and'' the templates.

\item[\textbf{Nondeterminism} ($c_1 \choice c_2$).] To solve the \textbf{Conservative
  Problem} we simply and the templates together, but to solve the
  \textbf{Flexible Problem} we may be able to constrain the problem (by
  constraining the packets) to either $c_1$ or $c_2$. This would require
  computing a $b_{\textit{pkt}}$.
\end{enumerate}



\subsection{Ghost State}


Following p4v, we want construct a ghostly header $\gamma$ from a program $p$
and use it to instrument the program to capture all dataplane behaviors.

\[
\begin{array}{l>{\triangleq}cl}
  \multicolumn{3}{l}{\ghostly :: \Cmd \to \Cmd} \\
  \multicolumn{3}{l}{\ghostly :: \Prog \to \GCL} \\
  \ghostly(h.f := e)
  && h.f := e \\
  \ghostly(\assert b)
  && \assert b\\
  \ghostly(\assume b)
  && \assume b \\
  \ghostly(c_1;c_2)
  && \ghostly(c_1);\ghostly(c_2) \\
  \ghostly(c_1\choice c_2)
  && \ghostly(c_1) \choice \ghostly(c_1)\\
  \ghostly(t.\apply())
  &&\\
  \multicolumn{3}{c}{
    \begin{array}[t]{>{\displaystyle\qquad}l}
       \gamma.t_{\mathit{reach}} := [1]_1; \\
       \gamma.t_{\mathit{read}(0)} := t.\keys[0]; \\
       \vdots \\
       \gamma.t_{\mathit{read}(|t.\keys|-1)} := t.\keys[|t.\keys|-1]; \\[1em]
       \left(\gamma.t_{\mathit{hit}} := [0]_1 \right)
       \choice \left(\bigchoice_{j = 1}^{|t.\action|-1}{
         \left(\begin{array}{l}
           \gamma.t_{\mathit{hit}} := [1]_1 ;\\
           \gamma.t_{\mathit{action}} := [1]_1;\\
           t.\action[j](\overrightarrow{\gamma.t_{\mathit{data}}})
         \end{array}\right)
       }\right)
     \end{array}}
\end{array}
\]

And now what we want to prove is

\begin{theorem}{Instrumentation sufficiency}
  For every well-formed program $c \in \Cmd$, every state $\sigma : \Value \to
  \Row^*$, there is some $b_\sigma \in \BExpr$ such that for every model $\mu
  \in \Model$ and every $\pkt \in \Pkt$,
  \[\denote{c}^\sigma\,\mu\,\pkt =_{\not\gamma} \denote{\ghostly(c);\assume b}^\sigma\,\mu\,\pkt\]
\end{theorem}

\begin{proof}
  Proceed by induction on $c$:
  \begin{enumerate}[align=left]
  \item[$(h.f:=e)$] Let $b_\sigma = \TRUE$; immediate.
  \item[$(\assume b)$] Let $b_\sigma = \TRUE$; immediate.
  \item[$(\assert b)$] Let $b_\sigma = \TRUE$; immediate.
  \item[$(c_1;c_2)$] By IHs. $b_\sigma = b_1 \wedge b_2$ because $b_1$ and $b_2$ refer to disjoint variables.
  \item[$(c_1 \choice c_2)$] \textit{sim}.
  \item[$(t.\apply())$]

    Let $b_\sigma$ be defined as follows:
    \[
    b_\sigma = \bigvee_{r \in \sigma(t.\id)}
    \begin{array}{>{\displaystyle}l}
      \gamma
    \end{array}
    \]

    We can compute as follows:
    \[\begin{array}{>{\displaystyle}ll}
    \denote{\ghostly(c)}^\sigma\,\mu\,\pkt\\
    =\denote{
        \begin{array}{>{\displaystyle}l}
          \gamma.t_{\mathit{reach}} := [1]_1; \\
          \gamma.t_{\mathit{read}(0)} := t.\keys[0]; \\
          \vdots \\
          \gamma.t_{\mathit{read}(|t.\keys|-1)} := t.\keys[|t.\keys|-1]; \\[1em]
          \left(\gamma.t_{\mathit{hit}} := [0]_1 \right)
          \choice \left(\bigchoice_{j = 1}^{|t.\action|-1}
            \left(\begin{array}{l}
              \gamma.t_{\mathit{hit}} := [1]_1 ;\\
              \gamma.t_{\mathit{action}} := j;\\
              t.\action[j](\overrightarrow{\gamma.t_{\mathit{data}}})
            \end{array}\right)
          \right)
    \end{array}}^\sigma\,\mu\,\pkt \\[2em]
    =\denote{
        \begin{array}{>{\displaystyle}l}
          \left(\gamma.t_{\mathit{hit}} := [0]_1 \right)
          \choice \left(\bigchoice_{j = 1}^{|t.\action|-1}
            \left(\begin{array}{l}
              \gamma.t_{\mathit{hit}} := [1]_1 ;\\
              \gamma.t_{\mathit{action}} := j;\\
              t.\action[j](\overrightarrow{\gamma.t_{\mathit{data}}})
            \end{array}\right)
          \right)
    \end{array}}^\sigma\!\mu\,\pkt' \\
    \qquad\qquad \text{where}~\pkt' = \pkt\left\{\begin{array}{l}
    \gamma.t_{\mathit{reach}} \mapsto [1]_1,\\
    \overrightarrow{\gamma.t_{\textit{key}} \mapsto \edenote{t.\keys}\,\pkt\,\mu}
    \end{array}\right\} \\
    =\denote{
      \left(\gamma.t_{\mathit{hit}} := [0]_1 \right)}^\sigma\!\mu\,\pkt'
    \cup
    \denote{\left(\bigchoice_{j = 1}^{|t.\action|-1}
            \left(\begin{array}{l}
              \gamma.t_{\mathit{hit}} := [1]_1 ;\\
              \gamma.t_{\mathit{action}} := j;\\
              t.\action[j](\overrightarrow{\gamma.t_{\mathit{data}}})
            \end{array}\right)
            \right)
    }^\sigma\!\mu\,\pkt' \\
    = \left\{(\mu,\pkt'\left\{\gamma.t_{\mathit{hit}} \mapsto [0]_1\right\})\right\}
    \cup
        \denote{\left(\bigchoice_{j = 1}^{|t.\action|-1}
          \left(\begin{array}{l}
            \gamma.t_{\mathit{hit}} := [1]_1 ;\\
            \gamma.t_{\mathit{action}} := j;\\
            t.\action[j](\overrightarrow{\gamma.t_{\mathit{data}}})
          \end{array}\right)
          \right)
        }^\sigma\!\mu\,\pkt' \\
  = \left\{(\mu,\pkt'\left\{\gamma.t_{\mathit{hit}} \mapsto [0]_1\right\})\right\}
  \cup
  \left(\bigcup_{j = 1}^{|t.\action|-1}
  \denote{t.\action[j](\overrightarrow{\gamma.t_{\mathit{data}}})}^\sigma\,\mu\,\pkt'\left\{
  \begin{array}{l}
    \gamma.t_{\textit{hit}} \mapsto [1]_1,\\
    \gamma.t_{\textit{action}} \mapsto j
  \end{array}
  \right\}
  \right) \\
    \end{array}
\]

  \end{enumerate}
\end{proof}


\subsection{Tables as nondeterministic choice}

Ive said before that the nondeterministic choice is an overapproximation of
the control plane behavior. It's a slightly inaccurate claim in that it
correctly captures all possible control plane behaviors, but it doesn't have a
handle on constrain control plane behavior.

A simplified version of P4v's encoding is shown in Figure~\ref{fig:p4vlike}. It
omits the key-reads commands and hit/miss predicates.

\begin{figure}
  \[\begin{array}{l >{\triangleq}cl}
  \multicolumn{3}{l}{\nondet : \Cmd \to \Cmd} \\
  \multicolumn{3}{l}{\nondet : \Prog \to \Instr} \\
  \nondet(h.f := e) && h.f := e \\
  \nondet(\assume b) && \assume b \\
  \nondet(\assert b) && \assert b \\
  \nondet(c_1;c_2) && \nondet(c_1;c_2) \\
  \nondet(c_1 \choice c_2) && \nondet(c_1) \choice \nondet(c_2) \\
  %% \nondet(\choose \rho t c) && \textcolor{red}{\text{undefined}} \\
  \nondet(t.\apply()) && \\
  \multicolumn{3}{>{\qquad}r}{
    \displaystyle
    \bigchoice_{i = 0}^{|t.\action|-1}t.\action[i]()
  }
  \end{array}\]
  \caption{A \texttt{p4v}-like instrumentation. For simplicity of reasoning
    about variables, assume that actions take no action data. }
  \label{fig:p4vlike}
\end{figure}

The theorem below demonstrates the over-approximation. Compare with the Instrumentation Equivalence Theorem~\ref{thm:instr-equiv}.

\begin{theorem}[\texttt{p4v} over-approximates]
  \label{thm:p4v-over}
  For every $c \in \Prog$, well-formed state $\sigma : \Value \to \Row^* $,
  model $\mu \in \Model$, and packet $\pkt \in \Pkt$,
  $\denote{c}^\sigma\,\mu\,\pkt \subseteq \denote{\nondet(c)}^\sigma\,\mu\,\pkt$
\end{theorem}

\begin{proof}
\todo[inline]{By induction on c}.
\end{proof}

We can witness non-equality by the following counter-example. Consider a program
$t.\apply()$ where $t = \{\keys=[h.f];\actions=[\lambda().\SKIP, \lambda(). h.f :=
  99]\}$. Consider an input packet with $\pkt(h.f) = 47$, and an empty input
model and state that selects a single action.

Then $\denote{t.\apply()}^\emptyset\,\emptyset\,\pkt = \{(\mu,\pkt)\}$.

Whereas
\[\begin{array}{l}
\denote{\nondet(t.\apply())}^\emptyset\,\emptyset\,\pkt \\
= \denote{
    \displaystyle
    \bigchoice_{i = 0}^{|t.\action|-1} t.\action[i]()
}^\emptyset\,\emptyset\,\pkt \\
= \denote{\SKIP}^\emptyset\,\emptyset\,\pkt \cup \denote{h.f := 99}^\emptyset\,\emptyset\,\pkt\\
= \{(\emptyset,\pkt),(\emptyset,\pkt\{h.f\mapsto 99\})\}
\end{array}\]

Finally, $\{(\emptyset,\pkt)\} \subset
\{(\emptyset,\pkt),(\emptyset,\pkt\{h.f\mapsto 99\})\}$, exemplifies a strict
subset behavior described by Theorem~\ref{thm:p4v-over}.


\end{document}
