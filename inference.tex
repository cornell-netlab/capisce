\documentclass{article}

\usepackage{amsmath, amssymb, amsthm, array, stmaryrd}
\usepackage{wasysym}
\usepackage{booktabs}
\usepackage{todonotes}
\usepackage{float}
\usepackage{scalerel}
%% \usepackage[notext,not1,nomath]{stix}
\usepackage{enumitem}

\title{Notes on Control Plane Inference}
\author{Eric Campbell}


% semantics
\newcommand{\pkt}{\mathit{pkt}}
\newcommand{\error}{\mathsf{error}}
\newcommand{\denote}[1]{\left\llbracket#1\right\rrbracket}
\newcommand{\edenote}[1]{\mathcal{E}\denote{#1}}

%booleans
\newcommand{\TRUE}{\mathsf{tt}}
\newcommand{\FALSE}{\mathsf{ff}}

%% bitvectors
\newcommand{\binop}{\mathbin{\oplus}}
\newcommand{\unop}{\mathop{\text{\pointer}}}

% sets
\newcommand{\Value}{\mathsf{Value}}
\newcommand{\BVExpr}{\mathsf{BVExpr}}
\newcommand{\BExpr}{\mathsf{BExpr}}
\newcommand{\Cmd}{\mathsf{Cmd}}
\newcommand{\Pkt}{\mathsf{Pkt}}
\newcommand{\Model}{\mathsf{Model}}
\newcommand{\Hdr}{\mathsf{Hdr}}
\newcommand{\Field}{\mathsf{Field}}
\newcommand{\Table}{\mathsf{Table}}
\newcommand{\Row}{\mathsf{Row}}
\newcommand{\List}{\mathsf{List}}
\newcommand{\Var}{\mathsf{Var}}
\newcommand{\SymbRow}{\mathsf{SymbRow}}

% record fields
\newcommand{\matches}{\mathsf{matches}}
\newcommand{\action}{\mathsf{action}}
\newcommand{\actions}{\mathsf{actions}}
\newcommand{\keys}{\mathsf{keys}}
\newcommand{\data}{\mathsf{data}}
\newcommand{\id}{\mathsf{id}}

% commands
\newcommand{\assert}{\mathop{\mathsf{assert}}}
\newcommand{\assume}{\mathop{\mathsf{assume}}}
\newcommand{\apply}{\mathsf{apply}}
\newcommand{\choiceop}{\rotatebox[origin=c]{90}{$\sqsubset\!\!\!\sqsupset$}}
\newcommand{\choice}{\mathbin{\choiceop}}
\DeclareMathOperator*{\bigchoice}{\scalerel*{\choiceop}{\sum}}
\renewcommand{\choose}[2]{\mathop{\mathsf{choose}~#1~\mathsf{from}~#2~\mathsf{in}}}
\newcommand{\SKIP}{\mathsf{skip}}

% math
\newcommand{\argmin}{\mathop{\textrm{argmin}}}

% defined functions
\newcommand{\tables}{\mathop{\mathsf{tables}}}


% Theorems
\newtheorem{theorem}{Theorem}


\begin{document}

\maketitle

\section{Preliminaries}

\subsection{Syntax}

\begin{figure}[htp]
  \[\begin{array}{lcll}
    \multicolumn{3}{l}{\Value} \\
    v & ::= & [n]_w  & \textit{Bitvector Literal}\\
    \multicolumn{3}{l}{\SymbRow} \\
    \rho & ::= & \left\{
    \begin{array}{l}
      \matches = \List[x];\\
      \action = x;\\
      \data = \List[x]
    \end{array}\right\} & \textit{Symbolic Row}\\
    \multicolumn{3}{l}{\BVExpr} \\
    e & ::= & v & \textit{Value}\\
      & \mid & h.f & \textit{Header Access} \\
      & \mid & \rho.\matches[i] & \textit{Symbolic Match} \\
      & \mid & \rho.\action & \textit{Symbolic Action}\\
      & \mid & \rho.\data[i] & \textit{Symbolic Action Data}\\
      & \mid & x & \textit{Variable}\\
      & \mid & e \binop e & \textit{Arbitrary Binary Operation}\\
    & \mid & \unop e & \textit{Arbitrary Unary Operation}\\
    \multicolumn{3}{l}{\Table} \\
    t & ::= & \left\{\begin{array}{l}
    t.\id = v; \\
    t.\keys = \List[h.f]; \\
    t.\actions = \List[\lambda \vec x. c]\\
    \end{array}\right\} & \textit{Table}\\
    \multicolumn{3}{l}{\BExpr} \\
    b & ::= & \FALSE  & \textit{Falsity}\\
      & \mid & b \Rightarrow b & \textit{Implication} \\
      & \mid & e = e & \textit{Bitvector Equality}\\
    & \mid & \forall \rho \in t.~b & \textit{Row Universality}\\
    \multicolumn{3}{l}{\Cmd} \\
    c & ::=  & h.f := e & \textit{Assignment}\\
      & \mid & \assert b & \textit{Assertion}\\
      & \mid & \assume b & \textit{Assumption}\\
      & \mid & t.\apply() & \textit{Table Application}\\
      & \mid & c;c & \textit{Sequential Composition} \\
    & \mid & c \choice c & \textit{Nondeterministic Choice}\\
    & \mid & \choose \rho t c & \textit{Selection} \\
    \multicolumn{3}{l}{
      \begin{array}{ll}
        x \in \Var & h \in \Hdr\\
        n,w,i \in \mathbb{N} & f \in \Field
    \end{array}} & \textit{Sets }\\
  \end{array}
\]
\caption{Grammar of Dataplane Programs}
\label{fig:grammar}
\end{figure}

The following sections describe aspects of the grammar shown in Figure~\ref{fig:grammar}.

\paragraph{Packets}
Our dataplane programs will reason about structured representations of packets,
that is, they will be transformations on sets of packet headers. In programs,
packet headers $h \in \Hdr$ are essentially structs with fields $f \in
\Field$. Write $h.f$ for a header $h$ and a field $f$ is the value $v$ of $f$
in header $h$.

\paragraph{Tables}
A table $t \in \Table$ is a record with a few fields described below:
\begin{enumerate}[align=left]
  \item[($t.\id$)] A table's unique identifier. A well-formed program can only have
    one occurence of each table identifier.
  \item[($t.\keys$)] A list of header field accesses indicating the match keys.
  \item[($t.\actions$)] A list of actions that can be executed. An action is a lambda
    expression $\lambda \vec x. c$ where the variables $x$ are in scope for the
    commands $c$, which $c$ are straight-line code only (see below).
\end{enumerate}
For now we assume that the default action is the no-operation command (see
$\SKIP$ below). We use $|l|$ to indicate the number of elements in a list or vector $l$
such as $t.\keys$ or $t.\actions$.


\paragraph{Symbolic Table Rows}
A symbolic table row $\rho \in \SymbRow$ represents a symbolic row. Like tables,
rows are also records with the following fields \todo{Well formedness constraint?}
\begin{enumerate}[align=left]
  \item[($\rho.\matches$)] A list variable of length representing the possible match keys.
  \item[($\rho.\action$)] A variable representing the action choice
  \item[($\rho.\data$)] A list variable representing the possible action data
\end{enumerate}

To represent the $i$th match variable in $\rho$, use standard list
access notation: $\rho.\matches[i]$.

Note that symbolic table rows are only meant to be used in the instrumentation
stage and not by a programmer.

\paragraph{Values}
Values $v \in \BVExpr$ are bitvector literals, written $[n]_w$, where $n$
is a natural value and $w$ is the width. We say that $[n]_w = [m]_l$ is
undefined if $w \neq l$, and otherwise is true iff $n \equiv m \mod 2^w$.

\paragraph{Bitvector Expressions}
Bitvector expressions $e \in \BVExpr$ can be values $v$, header accesses $h.f$,
symbolic row variables, variables $x$, or any
(currently unspecified) binary or unary bitvector operation.

\paragraph{Boolean Expressions}
Boolean expressions $b \in \BExpr$ can be $\FALSE$, implication ($b_1
\Rightarrow b_2$), equality of bitvector expressions ($e_1 = e_2$ for two
bitvector expressions $e_1$ and $e_2$), or universal quantification $\forall
\rho \in t. b$, where $\rho$ is a symbolic row in table $t$. Note that universal
quantification is meant to only be used by the instrumentation mechanism and not
a programmer.

We can represent other standard boolean operators by using standard encodings:
\[\begin{array}{l}
  \TRUE \triangleq \TRUE \Rightarrow \TRUE \\
  \neg b \triangleq b \Rightarrow \FALSE \\
  b_1 \vee b_2 \triangleq \neg b_1 \Rightarrow b_2 \\
  b_1 \wedge b_2 \triangleq \neg(\neg b_1 \vee \neg b_2) \\
  \vec e = \vec e' \triangleq \bigwedge_i e_i = e'_i
\end{array}\]

\paragraph{Commands}
Data plane programs $c \in \mathsf{Cmd}$ can be assignments ($h.f := e$),
assumptions ($\assume b$), assertions ($\assert b$), table application
($t.\apply()$), lexically-scoped nondeterministic selection ($\choose \rho t c$), sequential composition ($c_1;c_2$ for two commands $c_1$ and
$c_2$), and nondeterministic choice ($c_1 \choice c_2$ for two commands $c_1$
and $c_2$).

For actions, we restrict the language to be generated by only assignment, assumption, assertion and sequence, excluding table application and nondeterministic choice.

We define $\SKIP$ as the following syntactic sugar $\assume \TRUE$.

Define $\tables(c) \subset \Table$ to be the set of all tables hat occur in $c$.

\subsection{Semantics}

First we describe the semantic objects packet and state before giving semantics
to bitvector expressions, boolean expressions, and commands.

\paragraph{Packets}
A packet $\pkt$ is a map from header fields to values. Use the syntax $\pkt[h.f
  \mapsto v]$ to represent the packet that is equivalent to $\pkt$ on all header
fields except $h.f$, which maps to $v$.

\paragraph{State}
On-switch state is represented by a mapping from tables identifiers $t.\id$ to
lists of rows $[r_1,\ldots,r_n] \in \Row(t)^*$.

A similar to a symbolic row $\rho$, a concrete row $r$ comprises a list of match
values $r.\matches$, an action identifier $r.\action$, and a list of action data
$r.\data$. A concrete row $r$ is in the set $\Row(t)$ if it is well formed for a
table $t$ iff the following conditions hold:
\begin{enumerate}
\item $|r.\matches| = |t.\keys|$
\item $r.\action < |t.\actions|$
\item $|r.\data| = |\vec x|$ where $\lambda \vec x. c = t.\actions[r.\action]$
\end{enumerate}\

A state map $\sigma : \Value \to \Row^*$ is well-formed for a command $c$ iff the
following conditions hold:
\begin{enumerate}
\item[\textsc{WellFormedRows}] For every $t\in \tables(c)$, every row in $\sigma(t.\id)$ is well-formed.
\item[\textsc{NoShadow}] For every $t \in \tables(c)$, with $r_1,\ldots,r_n =
  \sigma(t.\id)$, for every $1 \leq i \leq n$, there does not exist $1 \leq j <
  i$ such that $r_i.\matches = r_j.\matches$.
\end{enumerate}
\todo[inline]{Tables(c) is undefined}

\paragraph{Row Models}
We also need models $\mu \in \Model$ to indicate which symbolic rows corresponds
to which concrete rows, i.e. $\Model = \SymbRow \rightharpoonup \Row$. We write
$\mu\{\rho \mapsto r\}$ to extend $\mu$ by mapping $\rho$ to $r$, and write $\mu
\setminus \rho$, to remove $\rho$ from the map.

\paragraph{Expressions}
The semantics of expressions is shown in Figure~\label{fig:sem-expr}. Note that
here we implicitly use the strict semantics for definedness, that is, operators
only succeed when all of their arguments are defined, otherwise it returns
undefined.

\begin{figure}[H]
  \[\begin{array}{l>{\triangleq}cl}
  \multicolumn{3}{l}{\edenote{e} : \Pkt \to \Model \rightharpoonup \Value }\\
    \edenote{v}~\pkt~\mu &&
    v \\
    \edenote{h.f}~\pkt~\mu &&
    pkt(h.f)\\
    \edenote{\rho.\matches[i]}~\pkt~\mu &&
    \mu(\rho).\matches[i] \\
    \edenote{\rho.\action}~\pkt~\mu &&
    \mu(\rho).\action \\
    \edenote{\rho.\data[i]} &&
    \mu(\rho).\data[i]\\
    \edenote{e_1 \binop e_2}~\pkt~\mu&&
    \edenote{e_1}~\pkt~\mu \binop
    \edenote{e_2}~\pkt~\mu \\
    \edenote{\unop e}~\pkt~\mu &&
    \unop \left(\edenote{e}~\pkt~\mu\right)
  \end{array}
  \]
  \caption{Semantics of Expressions}
  \label{fig:sem-expr}
\end{figure}

\paragraph{Boolean Satisfaction}
The satisfaction relation $\pkt,\mu \models_\sigma b$ is defined in
Figure~\ref{fig:bool-satis} in terms of the three kinds of variable contexts,
packets, models, and states. We also use the strict semantics here, most
importantly in the equality rule. Sometimes two expressions are considered equal
if they are both undefined; we do not take this approach, considering the
equality undefined if either argument is undefined.

\begin{figure}
  \[\begin{array}{l>{\iff}cl}
  \pkt,\mu \models_\sigma \FALSE && \textit{pigs fly} \\
  \pkt,\mu \models_\sigma b_1 \Rightarrow b_2 &&
  \pkt,\mu \not\models_\sigma b_1~\textit{or}~
  \pkt,\mu \models_\sigma b_2\\
  \pkt,\mu \models_\sigma e_1 = e_2 &&
  \edenote{e_1}~\pkt~\mu = \edenote{e_2}~\pkt~\mu, \qquad
  \text{(note strict semantics)} \\
  \pkt,\mu \models_\sigma \forall \rho \in t. ~b &&
  \forall r \in \sigma(t.\id).
  \pkt,\sigma,\mu[\rho \mapsto r] \models b
  \end{array}
  \]
  \caption{Satisfaction for $\BExpr$. Write $\pkt \models_\sigma b$ as syntactic
    sugar when the model $\mu$ is empty.}
  \label{fig:bool-satis}
\end{figure}

\paragraph{Command Evaluation}
Commands are evaluated similar to Avenir in Figure~\ref{fig:com-sem}. The
notable differences are the inclusion of assertions, the nondeterminism
operators, and a cleaner representation of table application.

\begin{figure}[htp]
  \[\begin{array}{l >{\triangleq}cl}
  \multicolumn{3}{l}{\denote{c}^\sigma : \Model \to \Pkt \to \mathcal{P}(\Model \times \Pkt)_\error }\\
    \denote{h.f := e}^\sigma~\mu~\pkt && \{(\mu, \pkt\{h \mapsto \edenote{e}~\pkt~\mu\})\} \\
    \denote{\assume b}^\sigma~\mu~\pkt &&
    \begin{cases}
      \{(\mu,\pkt)\} & \pkt,\mu \models_\sigma b \\
      \{\} & \textit{otherwise} \\
    \end{cases}\\
    \denote{\assert b}^\sigma~\mu~\pkt &&
    \begin{cases}
      \{(\mu,\pkt)\} & \pkt,\mu \models_\sigma b \\
      \error & \textit{otherwise}
    \end{cases} \\
    \denote{\choose \rho t c}^\sigma~\mu~\pkt &&
    \{(\mu'\setminus \rho,\pkt')
    \mid (\mu',\pkt') \in \denote{c}^\sigma\,(\mu\{\rho\mapsto r\})\,\pkt, r \in \sigma(t)\}
    \\
    \denote{c_1;c_2}^\sigma~\mu~\pkt&&
    \bigcup_{(\mu',\pkt') \in \denote{c_1}^\sigma\,\mu\,\pkt}\denote{c_2}^\sigma~\mu'~\pkt' \\
    \denote{c_1 \choice c_2}^\sigma~\mu~\pkt &&
    \denote{c_1}^\sigma~\mu~\pkt \cup \denote{c_2}^\sigma~\mu~\pkt \\
    \denote{t.\apply()}^\sigma~\mu~\pkt &&
    \begin{cases}
      \denote{c[\vec d/\vec x]}^\sigma~\mu~\pkt,
      & \text{where}~\lambda \vec x.~c = r.\action, \vec d = r.\data \\
      & \text{where}~r = \argmin_i\{\pkt,\mu \models_\sigma b_i\} \\
      & \text{where}~b_i = \sigma(t.\id)[i].\matches = t.\keys \\
      \{(\mu,\pkt)\}, & \mathit{otherwise}
    \end{cases}
  \end{array}\]
  \caption{Semantics of Commands}
  \label{fig:com-sem}
  \todo[inline]{$\Model$ then $\Pkt$ everywhere.}
\end{figure}

\section{Encoding}

Now we will define a collection of source-to-source translations that deal with
the controller interface.

\section{Eliminating Tables}

The first thing to do is to define a source-to-source translation that
eliminates the tables. The observation here is that tables essentially represent
if-else statements, so once we have a state $\sigma$ in hand we can rewrite the
program to a command $c[\sigma] \in \Cmd$ that uses no tables. This translation
is defined in Figure~\ref{fig:table-elim}

\begin{figure}
  \[\begin{array}{r>{\triangleq}cl}
  (h.f := e)[\sigma] && h.f := e   \\
  (\assume b)[\sigma] && \assume b \\
  (\assert b)[\sigma] && \assert b \\
  (c_1;c_2)[\sigma] && c_1[\sigma];c_2[\sigma] \\
  (c_1 \choice c_2)[\sigma] && c_1[\sigma] \choice c_2[\sigma] \\
  (\choose \rho t c)[\sigma] && \textrm{\textcolor{red}{unnecessary, but similar to t.apply}}\\
  (t.\apply())[\sigma] &&
  \begin{array}[t]{l}
    \{\\
    \quad \assume {r_1.\matches = t.\keys};\\
    \quad t.\action[r_1.\action](r_1.\data)\\
    \}~\choice\\
    \multicolumn{1}{c}{\vdots}\\
    \choice~\{\\
    \quad \assume {r_n.\matches = t.\keys};\\
    \quad t.\action[r_n.\action](r_n.\data)\\
    \}\\
    \textrm{where}~[r_1;\ldots;r_n] = \sigma(t.\id)
  \end{array}
  \end{array}
  \]
  \caption{Table Elimination}
  \label{fig:table-elim}
\end{figure}


\begin{theorem}[Table Elimination]
  For every $c \in \Cmd$, well-formed state $\sigma : \Value \to \Row^*$, model
  $\mu \in \Model$, and packet $\pkt \in \Pkt$, then for any state $\tau :
  \Value \to \Row^*$,
  \[\denote{c}^\sigma~\mu~\pkt = \denote{c[\sigma]}^\tau~\mu~\pkt\]
\end{theorem}
\begin{proof}
\todo[inline]{By induction on the structure of $c$.}
\end{proof}

\section{Instrumenting Tables}

The next step is to define a source to source translation that eliminates tables
in the absence of concrete table state, which we will write $c[?] \in \Cmd$.
This is the first step towards the goal of constraining control plane behavior.
Want the instrumented program $c[?]$ to fail on exactly the same situations that
$c[\sigma]$ does, however $c[?]$ is constrained to have no table applications.
The only remaining mechanism is to use $\assume$ and $\assert$ statements to
inspect $\sigma$. We define $c[?]$ in Figure~\ref{fig:table-instrument}.


\begin{figure}[htp]
  \[\begin{array}{r >{\triangleq}cl}
  (h.f := e)[?] && h.f := e \\
  (\assume b)[?] && \assume b \\
  (\assert b)[?] && \assert b\\
  (c_1;c_2)[?] && c_1[?];c_2[?]\\
  (c_1 \choice c_2)[?] && c_1[?] \choice c_2[?]\\
  (\choose \rho t c)[?] &&
  \textrm{\textcolor{red}{unnecessary}} \\
  (t.\apply())[?] &&
  \begin{array}[t]{l} \displaystyle
    \{ \\
    \quad \choose \rho t \;\{ \\
    \qquad \assume \rho.\matches = t.\keys; \\
    \qquad \displaystyle \bigchoice_{i=0}^{|t.\action| -1}
    \left\{\begin{array}{l}
    \assume \rho.\action = i;\\
    t.\action[i](\rho.\data)
    \end{array}\right\}\\
    \quad \} \\
    \} \choice \{ \\
    \quad \assume \forall \rho \in t. \rho.\matches \neq t.\keys; \\
    \quad \SKIP \\
    \quad \}\\
    \}
  \end{array}
  \end{array}
  \]
  \caption{Symbolic Table instrumentation}
  \label{fig:table-instrument}
\end{figure}

\begin{theorem}[Instrumentation Expressivity]
  For every $c \in \Cmd$, well-formed state $\sigma : \Value \to \Row^*$, model
  $\mu \in \Model$, and packet $\pkt \in \Pkt$, $\denote{c}^\sigma~\mu~\pkt =
  \denote{c[?]}^\sigma~\mu~\pkt$.
\end{theorem}

\begin{proof}
  Proceed by induction on the structure of $c$, leaving $\sigma$, $\mu$, $\pkt$ general.
  \begin{enumerate}[align=left]
  \item[$(c = h.f := e)$]
    Let $\sigma$,$\mu$,$\pkt$ be given.
    By definition $h.f:=e[?] = h.f:=e$. The result follows.
  \item[$(c = \assume b)$] Similar. $[?]$ is no-op.
  \item[$(c = \assert b)$] Similar. $[?]$ is no-op.
  \item[$(c = \choose \rho t)$] \textcolor{red}{Admitted}.
  \item[$(c = c_1;c_2)$]
    Let $\sigma,\mu,\pkt$ be given.
    By definition $(c_1;c_2)[?] = c_1[?]; c_2[?]$.
    Compute as follows:
    \[\begin{array}{>{\displaystyle}ll}
    \denote{(c_1;c_2)[?]}^\sigma~\mu~\pkt \\
    = \denote{c_1[?];c_2[?]}^\sigma~\mu\pkt
    & \text{by definition of } [?]  \\
    = \bigcup_{(\mu',\pkt') \in \denote{c_1[?]}^\sigma\,\mu\,\pkt}\denote{c_2[?]}^\sigma~\mu'~\pkt'
    & \text{by definition of }\denote{-} \\
    = \bigcup_{(\mu',\pkt') \in \denote{c_1}^\sigma\,\mu\,\pkt}\denote{c_2[?]}^\sigma~\mu'~\pkt'
    & \text{by } \mathit{IH}(c_1, \mu, \pkt) \\
    = \bigcup_{(\mu',\pkt') \in \denote{c_1}^\sigma\,\mu\,\pkt}\denote{c_2}^\sigma~\mu'~\pkt'
    & \text{by } \mathit{IH}(c_2, \mu', \pkt') \\
    = \denote{c_1;c_2}^\sigma~\mu~\pkt
    & \text{by definition of } \denote{-}
    \end{array}
    \]
  \item[$(c = c_1 \choice c_2)$] Similar, by IHs.

  \item[$(c = t.\apply())$]
    Let $\sigma$,$\mu$,$\pkt$ be given.
    Let $r_1,\ldots,r_n = \sigma(t)$.
    There are two cases, either the packet hits a row, or hits no row. Explore each case separately.
    \begin{enumerate}
    \item[\textsc{Hit}] In this case, there is some $r_i$ such that $\pkt,\mu
      \models_\sigma r_i.\matches = t.\keys$. By the well-formedness assumption,
      we know that this $r_i$ is unique, and that we can write
      $t.\actions[r_i.\action]$ as $\lambda \vec x. c$, and $|r_i.\data| = |\vec x|$.

      Compute as follows:
      \[\begin{array}{>{\displaystyle}ll}
      \denote{t.\apply()}^\sigma~\mu~\pkt \\
      = \denote{c[r_i.data/\vec x]}^\sigma~\mu~\pkt & \text{by definition of} \models \text{, and the uniqueness of }r_i  \\
      \end{array}
      \]

      Now, we compute the denotation of $t.\apply()[?]$ to see that it is equivalent to the above.
      The definition of $t.\apply()[?]$ gives us two alternatives. Consider the second, first:
      \[\begin{array}{>{\displaystyle}ll}
        \denote{\assume \forall \rho \in t. \rho.\matches \neq t.\keys;\SKIP}^\sigma~\mu~\pkt \\
        = \denote{\assume \forall \rho \in t. \rho.\matches \neq t.\keys}^\sigma~\mu~\pkt
        & \textrm{\textcolor{red}{Redo with defaults}} \\
        = \begin{cases}
          \{(\mu,\pkt)\}, & \pkt,\mu \models_\sigma \rho.\matches \neq t.\keys \\
          \{\}, &\textit{otherwise}
        \end{cases}
        & \textrm{By definition of }\denote{-}\\
        =  \{\}
        & \textrm{by \textsc{Hit} assumption}
      \end{array}
      \]

      Now let's consider the first branch, i.e.
      \[
      \denote{\choose \rho t \left\{
        \begin{array}{>{\displaystyle}l}
          \assume \rho.\matches = t.\keys;\\
          \bigchoice_{i=0}^{|t.\action| -1}
          \left\{\begin{array}{l}
          \assume \rho.\action = i;\\
          t.\actions[i](\rho.\data)
          \end{array}\right\}
        \end{array}\right\}
      }^\sigma~\mu~\pkt\]

      Compute the following inner result, by definitions and set theory
      \[
      \begin{array}{>{\displaystyle}ll}
      \bigcup_{r \in \sigma(t)}\denote{\begin{array}{>{\displaystyle}l}
          \assume \rho.\matches = t.\keys;\\
          \bigchoice_{i=0}^{|t.\action| -1}
          \left\{\begin{array}{l}
          \assume \rho.\action = i;\\
          t.\actions[i](\rho.\data)
          \end{array}\right\}
      \end{array}}^\sigma~\mu\{\rho \mapsto r\}~\pkt\\
      = \bigcup_{
        \substack{r \in \sigma(t) \\
          (\mu',\pkt') \in \denote{\assume \rho.\matches = t.\keys}^\sigma\,(\mu\{\rho \mapsto r\})\,\pkt}}
      \bigcup_{i=0}^{|t.\action| -1}\denote{
       \begin{array}{l}
          \assume \rho.\action = i;\\
          t.\actions[i](\rho.\data)
      \end{array}}^\sigma~\mu'~\pkt'

      \\\\
      (\textrm{by \textsc{Hit}, \textsc{NoShadow}, and the definition of }\denote{-}) \\
      \\
      = \bigcup_{i=0}^{|t.\action| -1}\denote{
       \begin{array}{l}
          \assume \rho.\action = i;\\
          t.\actions[i](\rho.\data)
      \end{array}}^\sigma~(\mu\{\rho \mapsto r_i\})~\pkt \\
      = \bigcup_{j=0}^{|t.\action| -1}\denote{
       \begin{array}{l}
          \assume r_i.\action = j;\\
          t.\actions[j](r_i.\data)
      \end{array}}^\sigma~(\mu\{\rho \mapsto r_i\})~\pkt \\
      \textrm{\textcolor{red}{TODO LEMMA}} \\
      = \denote{t.\actions[r_i.\action](r_i.\data)}^\sigma~(\mu\{\rho \mapsto r_i\})~\pkt \\
      = \denote{c[r_i.\data/\vec x]}^\sigma~(\mu\{\rho \mapsto r_i\})~\pkt
      \end{array}\]

      Since $\rho$ is fresh in $c$, and consequently in $c[r_i.\data/\vec x]$,
      then by \textcolor{red}{Lemma},
      \[\{(\mu'\setminus \rho,\pkt')
      \mid (\mu', \pkt') \in \denote{c[r_i.\data/\vec x]}^\sigma~(\mu\{\rho \mapsto r_i\})~\pkt\}
       = \denote{c[r_i.\data/\vec x]}^\sigma~\mu~\pkt
       \]
       \todo[inline]{Relies on the fact that $\rho \not \in \mu$, or that $\rho$ is globally fresh}

       The result follows.

    \item[\textsc{Miss}]
      \todo[inline]{Should be easy}

    \end{enumerate}

  \end{enumerate}
\end{proof}

\end{document}
