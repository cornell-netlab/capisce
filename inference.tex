\documentclass{article}

\usepackage{amsmath, amssymb, amsthm, array, stmaryrd}
\usepackage{wasysym}
\usepackage{booktabs}
\usepackage{todonotes}
\usepackage{float}
%% \usepackage[notext,not1,nomath]{stix}
\usepackage{enumitem}

\title{Notes on Control Plane Inference}
\author{Eric Campbell}


% semantics
\newcommand{\pkt}{\mathit{pkt}}
\newcommand{\denote}[1]{\llbracket#1\rrbracket}
\newcommand{\edenote}[1]{\mathcal{E}\denote{#1}}

%booleans
\newcommand{\TRUE}{\mathsf{tt}}
\newcommand{\FALSE}{\mathsf{ff}}

%% bitvectors
\newcommand{\binop}{\mathbin{\oplus}}
\newcommand{\unop}{\mathop{\text{\pointer}}}

% sets
\newcommand{\Value}{\mathsf{Value}}
\newcommand{\BVExpr}{\mathsf{BVExpr}}
\newcommand{\BExpr}{\mathsf{BExpr}}
\newcommand{\Cmd}{\mathsf{Cmd}}
\newcommand{\Pkt}{\mathsf{Pkt}}
\newcommand{\Model}{\mathsf{Model}}
\newcommand{\Hdr}{\mathsf{Hdr}}
\newcommand{\Field}{\mathsf{Field}}
\newcommand{\Table}{\mathsf{Table}}
\newcommand{\Row}{\mathsf{Row}}
\newcommand{\List}{\mathsf{List}}
\newcommand{\Var}{\mathsf{Var}}
\newcommand{\SymbRow}{\mathsf{SymbRow}}

% record fields
\newcommand{\matches}{\mathsf{matches}}
\newcommand{\action}{\mathsf{action}}
\newcommand{\actions}{\mathsf{actions}}
\newcommand{\keys}{\mathsf{keys}}
\newcommand{\data}{\mathsf{data}}
\newcommand{\id}{\mathsf{id}}

% commands
\newcommand{\assert}{\mathop{\mathsf{assert}}}
\newcommand{\assume}{\mathop{\mathsf{assume}}}
\newcommand{\apply}{\mathsf{apply}}
\newcommand{\choice}{\mathbin{\rotatebox[origin=c]{90}{$\sqsubset\!\!\!\sqsupset$}}}
\newcommand{\SKIP}{\mathsf{skip}}

%math
\newcommand{\argmin}{\mathop{\textrm{argmin}}}


% Old
\newcommand{\NumRows}{\mathsf{numrows}}
\newcommand{\MatchRow}{\mathsf{keys}}
\newcommand{\ActionRow}{\mathsf{action}}
\newcommand{\ActionDataRow}{\mathsf{data}}

\begin{document}

\maketitle

\section{Preliminaries}

\subsection{Syntax}

\begin{figure}[htp]
  \[\begin{array}{lcll}
    \multicolumn{3}{l}{\Value} \\
    v & ::= & [n]_w  & \textit{Bitvector Literal}\\
    \multicolumn{3}{l}{\SymbRow} \\
    \rho & ::= & \left\{
    \begin{array}{l}
      \matches = \List[x];\\
      \action = x;\\
      \data = \List[x]
    \end{array}\right\} & \textit{Symbolic Row}\\
    \multicolumn{3}{l}{\BVExpr} \\
    e & ::= & v & \textit{Value}\\
      & \mid & h.f & \textit{Header Access} \\
      & \mid & \rho.\matches[i] & \textit{Symbolic Match} \\
      & \mid & \rho.\action & \textit{Symbolic Action}\\
      & \mid & \rho.\data[i] & \textit{Symbolic Action Data}\\
      & \mid & x & \textit{Variable}\\
      & \mid & e \binop e & \textit{Arbitrary Binary Operation}\\
    & \mid & \unop e & \textit{Arbitrary Unary Operation}\\
    \multicolumn{3}{l}{\Table} \\
    t & ::= & \left\{\begin{array}{l}
    t.\id = v; \\
    t.\keys = \List[h.f]; \\
    t.\actions = \List[\lambda \vec x. c]\\
    \end{array}\right\} & \textit{Table}\\
    \multicolumn{3}{l}{\BExpr} \\
    b & ::= & \FALSE  & \textit{Falsity}\\
      & \mid & b \Rightarrow b & \textit{Implication} \\
      & \mid & e = e & \textit{Bitvector Equality}\\
    & \mid & \forall \rho \in t.~b & \textit{Row Universality}\\
    \multicolumn{3}{l}{\Cmd} \\
    c & ::=  & h.f := e & \textit{Assignment}\\
      & \mid & \assert b & \textit{Assertion}\\
      & \mid & \assume b & \textit{Assumption}\\
      & \mid & t.\apply() & \textit{Table Application}\\
      & \mid & c;c & \textit{Sequential Composition} \\
    & \mid & c \choice c & \textit{Nondeterministic Choice}\\
    \multicolumn{3}{l}{
      \begin{array}{ll}
        x \in \Var & h \in \Hdr\\
        n,w,i \in \mathbb{N} & f \in \Field
    \end{array}} & \textit{Sets }\\
  \end{array}
\]
\caption{Grammar of Dataplane Programs}
\label{fig:grammar}
\end{figure}

The following sections describe aspects of the grammar shown in Figure~\ref{fig:grammar}.

\paragraph{Packets}
Our dataplane programs will reason about structured representations of packets,
that is, they will be transformations on sets of packet headers. In programs,
packet headers $h \in \Hdr$ are essentially structs with fields $f \in
\Field$. Write $h.f$ for a header $h$ and a field $f$ is the value $v$ of $f$
in header $h$.

\paragraph{Tables}
A table $t \in \Table$ is a record with a few fields described below:
\begin{enumerate}[align=left]
  \item[($t.\id$)] A table's unique identifier. A well-formed program can only have
    one occurence of each table identifier.
  \item[($t.\keys$)] A list of header field accesses indicating the match keys.
  \item[($t.\actions$)] A list of actions that can be executed. An action is a lambda
    expression $\lambda \vec x. c$ where the variables $x$ are in scope for the
    commands $c$, which $c$ are straight-line code only (see below).
\end{enumerate}
For now we assume that the default action is the no-operation command (see
$\SKIP$ below). We use $|l|$ to indicate the number of elements in a list or vector $l$
such as $t.\keys$ or $t.\actions$.


\paragraph{Symbolic Table Rows}
A symbolic table row $\rho \in \SymbRow$ represents a symbolic row. Like tables,
rows are also records with the following fields \todo{Well formedness constraint?}
\begin{enumerate}[align=left]
  \item[($\rho.\matches$)] A list variable of length representing the possible match keys.
  \item[($\rho.\action$)] A variable representing the action choice
  \item[($\rho.\data$)] A list variable representing the possible action data
\end{enumerate}

To represent the $i$th match variable in $\rho$, use standard list
access notation: $\rho.\matches[i]$.

Note that symbolic table rows are only meant to be used in the instrumentation
stage and not by a programmer.

\paragraph{Values}
Values $v \in \BVExpr$ are bitvector literals, written $[n]_w$, where $n$
is a natural value and $w$ is the width. We say that $[n]_w = [m]_l$ is
undefined if $w \neq l$, and otherwise is true iff $n \equiv m \mod 2^w$.

\paragraph{Bitvector Expressions}
Bitvector expressions $e \in \BVExpr$ can be values $v$, header accesses $h.f$,
symbolic row variables, variables $x$, or any
(currently unspecified) binary or unary bitvector operation.

\paragraph{Boolean Expressions}
Boolean expressions $b \in \BExpr$ can be $\FALSE$, implication ($b_1
\Rightarrow b_2$), equality of bitvector expressions ($e_1 = e_2$ for two
bitvector expressions $e_1$ and $e_2$), or universal quantification $\forall
\rho \in t. b$, where $\rho$ is a symbolic row in table $t$. Note that universal
quantification is meant to only be used by the instrumentation mechanism and not
a programmer.

We can represent other standard boolean operators by using standard encodings:
\[\begin{array}{l}
  \TRUE \triangleq \TRUE \Rightarrow \TRUE \\
  \neg b \triangleq b \Rightarrow \FALSE \\
  b_1 \vee b_2 \triangleq \neg b_1 \Rightarrow b_2 \\
  b_1 \wedge b_2 \triangleq \neg(\neg b_1 \vee \neg b_2) \\
  \vec e = \vec e' \triangleq \bigwedge_i e_i = e'_i
\end{array}\]

\paragraph{Commands}
Data plane programs $c \in \mathsf{Cmd}$ can be assignments ($h.f := e$),
assumptions ($\assume b$), assertions ($\assert b$), table application
($t.\apply()$), sequential composition ($c_1;c_2$ for two commands $c_1$ and
$c_2$), and nondeterministic choice ($c_1 \choice c_2$ for two commands $c_1$
and $c_2$).

For actions, we restrict the language to be generated by only assignment, assumption, assertion and sequence, excluding table application and nondeterministic choice.

We define $\SKIP$ as the following syntactic sugar $\assume \TRUE$.

\subsection{Semantics}

First we describe the semantic objects packet and state before giving semantics
to bitvector expressions, boolean expressions, and commands.

\paragraph{Packets}
A packet $\pkt$ is a map from header fields to values. Use the syntax $\pkt[h.f
  \mapsto v]$ to represent the packet that is equivalent to $\pkt$ on all header
fields except $h.f$, which maps to $v$.

\paragraph{State}
On-switch state is represented by a mapping from tables identifiers $t.\id$ to
lists of rows $[r_1,\ldots,r_n] \in \Row(t)^*$.

A similar to a symbolic row $\rho$, a concrete row $r$ comprises a list of match
values $r.\matches$, an action identifier $r.\action$, and a list of action data
$r.\data$. A concrete row $r$ is in the set $\Row(t)$ if it is well formed for a
table $t$ iff the following conditions hold:
\begin{enumerate}
\item $|r.\matches| = |t.\keys|$
\item $r.\action < |t.\actions|$
\item $|r.\data| = |\vec x|$ where $\lambda \vec x. c = t.\actions[r.\action]$
\end{enumerate}\

\paragraph{Row Models}
We also need models $\mu \in \Model$ to indicate which symbolic rows corresponds
to which concrete rows, i.e. $\Model$ is a map from symbolic rows to concrete
rows; write $\mu(\rho) = r$ for a model $\mu$, a symbolic row $\rho$, and a
concrete row $r$.

\paragraph{Expressions}
The semantics of expressions is shown in Figure~\label{fig:sem-expr}. Note that
here we implicitly use the strict semantics for definedness, that is, operators
only succeed when all of their arguments are defined, otherwise it returns
undefined.

\begin{figure}[htp]
  \[\begin{array}{l>{\triangleq}cl}
  \multicolumn{3}{l}{\edenote{e} : \Pkt \to \Model \rightharpoonup \Value }\\
    \edenote{v}~\pkt~\mu &&
    v \\
    \edenote{h.f}~\pkt~\mu &&
    pkt(h.f)\\
    \edenote{\rho.\matches[i]}~\pkt~\mu &&
    \mu(\rho).\matches[i] \\
    \edenote{\rho.\action}~\pkt~\mu &&
    \mu(\rho).\action \\
    \edenote{\rho.\data[i]} &&
    \mu(\rho).\data[i]\\
    \edenote{e_1 \binop e_2}~\pkt~\mu&&
    \edenote{e_1}~\pkt~\mu \binop
    \edenote{e_2}~\pkt~\mu \\
    \edenote{\unop e}~\pkt~\mu &&
    \unop \left(\edenote{e}~\pkt~\mu\right)
  \end{array}
  \]
  \caption{Semantics of Expressions}
  \label{fig:sem-expr}
\end{figure}

\paragraph{Boolean Satisfaction}
The satisfaction relation $\pkt,\mu \models_\sigma b$ is defined in
Figure~\ref{fig:bool-satis} in terms of the three kinds of variable contexts,
packets, models, and states. We also use the strict semantics here, most
importantly in the equality rule. Sometimes two expressions are considered equal
if they are both undefined; we do not take this approach, considering the
equality undefined if either argument is undefined.

\begin{figure}
  \[\begin{array}{l>{\iff}cl}
  \pkt,\mu \models_\sigma \FALSE && \textit{pigs fly} \\
  \pkt,\mu \models_\sigma b_1 \Rightarrow b_2 &&
  \pkt,\mu \not\models_\sigma b_1~\textit{or}~
  \pkt,\mu \models_\sigma b_2\\
  \pkt,\mu \models_\sigma e_1 = e_2 &&
  \edenote{e_1}~\pkt = \edenote{e_2}~\pkt, \qquad
  \text{(note strict semantics)} \\
  \pkt,\sigma \models \edenote{\forall \rho \in t. b} &&
  \forall r \in \sigma(t.\id).
  \pkt,\sigma,\mu[\rho \mapsto r] \models b
  \end{array}
  \]
  \caption{Satisfaction for $\BExpr$. Write $\pkt \models_\sigma b$ as syntactic
    sugar when the model $\mu$ is empty.}
  \label{fig:bool-satis}
\end{figure}

\paragraph{Command Evaluation}
Commands are evaluated similar to Avenir in Figure~\ref{fig:com-sem}. The
notable differences are the inclusion of assertions, the use of a binary
nondeterminism operator, and a cleaner representation of table application.

\begin{figure}[htp]
  \[\begin{array}{l >{\triangleq}cl}
  \multicolumn{3}{l}{\denote{c} : \Pkt \to 2^\Pkt_\bot }\\
    \denote{h.f := e}^\sigma~\pkt && \{\pkt\{h \mapsto \edenote{e}\pkt\}\} \\
    \denote{\assume b}^\sigma~\pkt &&
    \begin{cases}
      \{\pkt\} & \pkt \models_\sigma b \\
      \{\} & \textit{otherwise} \\
    \end{cases}\\
    \denote{\assert b}^\sigma \pkt &&
    \begin{cases}
      \{pkt\} & \pkt \models_\sigma b \\
      \bot & \textit{otherwise}
    \end{cases} \\
    \denote{c_1;c_2}^\sigma \pkt&&
    \bigcup_{\pkt' \in \denote{c_1}\pkt}\denote{c_2}~\pkt' \\
    \denote{c_1 \choice c_2}^\sigma \pkt &&
    \denote{c_1}^\sigma~\pkt \cup \denote{c_2}^\sigma~\pkt \\
    \denote{t.\apply()}^\sigma \pkt &&
    \begin{cases}
      \denote{c[\vec d/\vec x]}^\sigma~\pkt,
      & \text{where}~\lambda \vec x.~c = r.\action, \vec d = r.\data \\
      & \text{where}~r = \argmin_i\{\pkt \models_\sigma \sigma(t.\id)[i].\matches = t.\keys \} \\

      \{\pkt\}, & \mathit{otherwise}
    \end{cases}

  \end{array}\]
  \caption{Semantics of Commands}
  \label{fig:com-sem}
\end{figure}


\subsection{Encoding}



%% \section{OLD}

%% Let $\delta$ be Control plane edits defined by the grammar
%% \[\begin{array}{lcl}
%%     \delta & ::= & \mathsf{Add}_t(\vec m,a(\vec k)) \\
%%            & \mid & \mathsf{Del}_t(\vec m) \\
%%   \end{array}\]

%% Write $\delta.\mathit{keys}$ to be the list of keys $\vec m$. When
%% $\delta$ is an \textsf{Add} operation, write $\delta.\mathit{action}$
%% to indicate the action $a$, and write $\delta.\mathit{data}$ to
%% indicate the argument list $\vec k$. For any list $\vec x$ write
%% $\vec x[i]$ for element $x_i$.

%% Define a control plane instance $\sigma$ to be a list of edits
%% $\delta$, and is minimal if there are no deletions and no shadowed
%% insertions. An insertion $\delta = \mathsf{Add}_t(\vec m, a(\vec k))$
%% is \emph{shadowed} in an instance $\sigma$ if $\sigma[i] = \delta$ and
%% every packet that matches $\delta$ matches a preceeding rule
%% $\sigma[j]$, $0 \leq k < i$. An instance $\sigma$ is minimal for a
%% program $p$ if for all $\sigma'$ such that
%% $\llbracket p[\sigma] \rrbracket = \llbracket p[\sigma'] \rrbracket$,
%% then $|\sigma| \leq |\sigma'|$.

%% The operation $\sigma(t)$ selects all the operations on table
%% $t$ in $\sigma$. To apply the edits $\sigma$ to a program $p$ as is
%% done in Avenir, write $p[\sigma] \in \mathsf{DProg}$.


%% Let $\varphi$ be a control plane constraint modelled by minimal lists
%% of edits. For a table $t$ let $t[i]$ be a record
%% $\{\MatchRow = \vec m; \ActionRow = \vec a; \ActionDataRow = \vec k\}$
%% representing the $i$th row in that table.  We can describe $\varphi$
%% by the boolean combinations of (in)equalities over the following
%% variables.
%% \begin{center}
%% \begin{tabular}{lll}
%%   \toprule
%%   Variable & Semantics on minimal $\sigma$\\
%%   \midrule
%%   $t.\NumRows$ & Denotes the number of edits in table $t$\\
%%   $t[i].\MatchRow(j)$ & In table $t$ the $j$th key in row $i$\\
%%   $t[i].\ActionRow$ & In table $t$ the action selected in row $i$\\
%%   $t[i].\ActionDataRow(j)$ & in table $t$ the $i$th action argument in row $i$\\
%%   \bottomrule
%% \end{tabular}
%% \end{center}

%% Then the grammar we get is:
%% \[
%%   \begin{array}{lcl}
%%     \varphi &::=& \bot \\
%%             & \mid & \varphi \Rightarrow \varphi \\
%%             & \mid & e < e  \\
%%     e       & ::= & n \\
%%             & \mid & [n]_w \\
%%             & \mid & t \\
%%             & \mid & e[i] \\
%%             & \mid & e.\NumRows \\
%%             & \mid & e.\MatchRow \\
%%             & \mid & e.\ActionRow \\
%%             & \mid & e.\ActionDataRow \\
%%   \end{array}
%% \]

%% We use $\psi$ to denote a formula that intermingles the control plane
%% variables above with dataplane variables like \texttt{ipv4.src\_addr}.

%% We write the modelling relation $\sigma \models \varphi$ to indicate
%% that $\sigma$ satisfies $\varphi$ in the standard
%% way with respect to the above semantics.

%% \[
%%   \begin{array}{rcl}
%%     \sigma \models \bot &\iff & \mathit{never} \\
%%     \sigma \models \varphi_1 \Rightarrow \varphi_2 & \iff & \sigma \not\models \varphi_1,~\text{or}~\sigma \models \varphi_2 \\
%%     \sigma \models e_1 < e_2 &\iff& \llbracket e_1 \rrbracket \sigma < \llbracket e_2 \rrbracket \sigma \\\\
%%     % \llbracket n \rrbracket \sigma & = & n \\
%%     % \llbracket [n]_w \rrbracket \sigma & = & [n]_w \\
%%     % \llbracket t \rrbracket \sigma & = & \sigma(t) \\
%%     % \llbracket e[i] \rrbracket \sigma & = & \sigma(t)[i], \mathit{where},~\llbracket e \rrbracket \sigma = \sigma(t),  \\
%%     % \llbracket e.\NumRows \rrbracket \sigma & = &  |\sigma(t)|, \mathit{where}~\llbracket e \rrbracket \sigma = \sigma(t)[i], \\
%%     % \vdots
%%   \end{array}
%% \]

%% \section{The Problem}

%% Given a program $p$, compute $\varphi$ such that for all
%% instantiations $\sigma$, $\sigma \models \varphi$ if (and
%% only if) one of the following (equivalent expressions) holds:
%% \begin{enumerate}
%% \item $\forall \mathit{pkt}. \llbracket p[\sigma]\rrbracket~\mathit{pkt} \neq \mathsf{error}$
%% \item $\mathit{wp}(p[\sigma], \top)$ is valid
%% \end{enumerate}

%% Our proposed solution is to instrument $p$ with ghost variables to
%% (completely) describe the unknowns in the program. Write the
%% instrumented program as $\mathcal{I}(p)$. An immediate strategy is to
%% replace any table application $t.\mathit{apply}()$, where
%% $t = (\mathsf{keys}= \vec k, \mathsf{actions} = \overrightarrow{a(\vec
%%   d)})$ which statically has a maxmimum number of rows $n$ with a
%% table of the following form:
%% \[
%%   \begin{array}{ll}
%%     \multicolumn{2}{l}{\mathsf{assume} (t.\mathsf{numrows} = 0) []}\\
%%     {[]}_{1 \leq r \leq n}
%%     & \mathsf{assume}(t.\mathsf{numrows} \geq r)\\
%%     & \mathsf{assume}(\bigwedge_l k_l = t[r].\MatchRow(l)); \\
%%     & {[]}_j (\mathsf{assume}(j = t[r].\ActionRow); \\
%%     & \quad\; \mathsf{assume}(\bigwedge_i d_i = t[r].\ActionDataRow(i)); \\
%%     & \quad\; a_j(\vec d)) \\
%%     )
%%   \end{array}
%% \]
%% This is the approach taken by Avenir's strawman simple synthesis
%% algorithm. P4v doesn't do such an enumeratively crazy instrumentation
%% procedure---it uses only one table row $t[0]$ rather than $n$ table
%% rows. More care is needed to figure out whether these are different or
%% the same.

%% Once we have this instrumentation, we can compute a verification
%% condition (VC), to constrain the ``safe'' behavior of the instrumented
%% program $\mathcal{I}(p)$. For the time being, we'll use the weakest
%% precondition predicate transformer
%% $\mathit{wp}(\mathcal{I}(p), \top)$, and notate the result as
%% $\psi_p$. Notice that this formula $\psi_p$ may contain both
%% dataplane variables, like $\texttt{ipv4.srcAddr}$ and control plane
%% ghost variables, like $t[i].\MatchRow(l)$. Write
%% $\psi_p[\vec{\texttt{d}},\vec{\mathsf{c}}]$ to denote that the free
%% variables of $\psi_p$ are the union of the dataplane variables
%% $\{\texttt{d}_1, \ldots,\texttt{d}_n\}$ and the control plane variables
%% $\{\mathsf{c}_1, \ldots, \mathsf{c}_m\}$.

%% Now we can reformulate the problem entirely logically. Given a program
%% $p$ and its corresponding instrumented verification condition
%% $\psi_p$, compute a controller constraint $\varphi$ such that the following equation is valid
%% %% \[(\forall \vec{\texttt{d}}.~\psi_p[\vec{\texttt{d}},\vec{\mathsf{c}}]) \iff \varphi[\vec{\mathsf{c'}}] \]
%% \[\varphi[\vec{\mathsf{c}}] \Rightarrow \psi_p[\vec{\texttt{d}},\vec{\mathsf{c}}] \]

%% Now we only need to investigate a quantifier elimination algorithm for
%% the variables $\vec{\texttt{d}}$. The standard algorithm (replace
%% every $\texttt{d}_i$ of sort $\texttt{(\_~BitVec~n)}$ with every
%% element in $\mathbf{2}^n$) for fixed-width bitvector theories is
%% intractable: a standard ethernet frame is $1500$ bits, and the number
%% of corresponding disjunctions is $2^{1500} = 10^{451.5\ldots}$, which
%% is far greater than the $10^{82}$ atoms in the universe.

%% However, I believe we can support a complete collection of rewrite
%% rules to eliminate these variables based leveraging the known
%% invariants about the program \& formula structures.

%% \section{Examples}

%% There are a few questions we want to investigate with examples.
%% \begin{enumerate}
%% \item \label{question:rowiter}
%%   Do we need to consider multiple rows at the same time? In other words, do
%%   we need to instrument each table $t$ with a different row for \(t[0]\ldots
%%   t[t.\mathsf{maxrows}]\) or is it sufficient to, like P4v, only consider a
%%   single row at a time?
%% \item \label{question:elimination}
%%   Can we eliminate all references to dataplane state in the conditions we
%%   generate?
%% \end{enumerate}

%% \subsection{A Multi-Table Example}
%% We will construct a pipeline with 3 tables, \(t_i\) for \(i=0,1,2\),
%% where each \(t_i\) matches on \(x_i\) and assigns a value to
%% \(y_i\).
%% \begin{verbatim}
%% table ti {
%%   keys : xi
%%   actions : ai
%%   default : ai(i)
%%   max_rows : 2
%% }
%% action ai(y){
%%   yi := y
%% }
%% \end{verbatim}

%% The control block applies \(t_0\), and then conditionally applies
%% \(t_1\) or \(t_2\). The assertion is that \(t_i\) is even for all \(i=0,1,2\).

%% \begin{verbatim}
%% y0 := 0;
%% y1 := 0;
%% y2 := 0;
%% t0.apply();
%% if (y0%3 = 0) {
%%   t1.apply()
%% } else {
%%   t2.apply()
%% }
%% assert y0%2 = 0;
%% assert y1%2 = 0;
%% assert y2%2 = 0;
%% \end{verbatim}

%% Now, we can instrument this program using the ghost state defined above.
%% \begin{verbatim}
%% y0 := 0; y1 := 0; y2 := 0;
%% assume t0[0].action <= 0;
%% assume t0[1].action <= 0;
%% assume t0.numrows <= 2;
%% { assume t0.numrows > 0 && t0[0].keys(x0) = x0;
%%   assume t0[0].action = 0;
%%   y0 := t0[0].data(y)
%% } [] {
%%  assume not (t0.numrows > 0 && t0[0].keys(x0) = x0);
%%  assume t0.numrows > 1  && t0[1].keys(x0) = x0;
%%  assume t0[1].action = 0;
%%  y0 := t0[1].data(y)
%% } [] {
%%  assume not (t0.numrows > 0 && t0[0].keys(x0) = x0);
%%  assume not (t0.numrows > 1 && t0[1].keys(x0) = x0);
%%  y0 := 0
%% };
%% {assume y0%3 = 0;
%%   assume t1[0].action <= 0;
%%   assume t1[1].action <= 0;
%%   assume t1.numrows <= 2;
%%   { assume t1.numrows > 0 && t1[0].keys(x1) = x1;
%%     assume t1[0].action = 0;
%%     y1 := t1[0].data(y)
%%   } [] {
%%     assume not (t1.numrows > 0 && t1[0].keys(x1) = x1);
%%     assume t1.numrows > 1  && t1[1].keys(x1) = x1;
%%     assume t1[1].action = 0;
%%     y1 := t1[1].data(y)
%%   } [] {
%%     assume not (t1.numrows > 0 && t1[0].keys(x1) = x1);
%%     assume not (t1.numrows > 1 && t1[1].keys(x1) = x1);
%%     y1 := 1
%%   }
%% } [] {
%%   assume y0%3 != 0;
%%   assume t2[0].action <= 0;
%%   assume t2[1].action <= 0;
%%   assume t2.numrows <= 2;
%%   { assume t2.numrows > 0 && t2[0].keys(x2) = x2;
%%     assume t2[0].action = 0;
%%     y2 := t2[0].data(y)
%%   } [] {
%%     assume not (t2.numrows > 0 && t2[0].keys(x2) = x2);
%%     assume t2.numrows > 1  && t2[1].keys(x2) = x2;
%%     assume t2[1].action = 0;
%%     y2 := t2[1].data(y)
%%   } [] {
%%     assume not (t2.numrows > 0 && t2[0].keys(x2) = x2);
%%     assume not (t2.numrows > 1 && t2[1].keys(x2) = x2);
%%     y2 := 2
%%   }
%% }
%% assert y0 % 2 = y1 % 2 = y2 % 2 = 0
%% \end{verbatim}

%% And finally, we can compute the weakest precondition to produce a (universally
%% closed) condition on variables.

%% \[
%% \begin{array}{l}
%%   t_0.\NumRows > 0 \wedge t_0[0].\MatchRow(x_0) = x_0 \\
%%   \Rightarrow
%%   \begin{array}[t]{l}
%%     t_0[0].\ActionDataRow(y) \% 3 = 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1 \\
%%       \qquad \Rightarrow t_1[0].\ActionDataRow(y) \% 2 = 0 \wedge t_0[0].\ActionDataRow(y)\% 2 = 0 \\
%%       \wedge (\neg (t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1) \\
%%       \phantom{\wedge(}\wedge (t_1.\NumRows > 1 \wedge t_1[1].\MatchRow(x_1) = x_1) \\
%%       \phantom{\wedge(}\Rightarrow t_1[1].\ActionDataRow(y) \% 2 = 0 \wedge t_0[1].\ActionDataRow(y)\% 2 = 0 )\\
%%       \wedge (\neg (t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1) \\
%%       \phantom{\wedge (}\wedge \neg (t_1.\NumRows > 1 \wedge t_1[1].\MatchRow(x_1) = x_1)) \\
%%     \end{array} \\
%%     \wedge\,t_0[0].\ActionDataRow(y) \% 3 \neq 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_2.\NumRows > 0 \wedge t_2[0].\MatchRow(x_2) = x_2 \\
%%       \qquad \Rightarrow t_2[0].\ActionDataRow(y) \% 2 = 0 \wedge t_0[0].\ActionDataRow(y)\% 2 = 0 \\
%%       \wedge (\neg (t_2.\NumRows > 0 \wedge t_2[0].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge(}\wedge (t_2.\NumRows > 1 \wedge t_2[1].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge(}\Rightarrow t_2[1].\ActionDataRow(y) \% 2 = 0 \wedge t_0[1].\ActionDataRow(y)\% 2 = 0 )\\
%%       \wedge (\neg (t_2.\NumRows > 0 \wedge t_2[0].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge (}\wedge \neg (t_2.\NumRows ? 1 \wedge t_2[1].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge (} t_0[1].\ActionDataRow(y) \% 2 = 0)
%%     \end{array}
%%   \end{array} \\
%%   t_0.\NumRows > 1 \wedge t_0[1].\MatchRow(x_0) = x_0 \\
%%   \wedge \neg (t_0.\NumRows > 0 \wedge t_0[0].\MatchRow(x_0) = x_0 ) \\
%%   \Rightarrow
%%   \begin{array}[t]{l}
%%     t_0[1].\ActionDataRow(y) \% 3 = 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1 \\
%%       \qquad \Rightarrow t_1[0].\ActionDataRow(y) \% 2 = 0 \wedge t_0[1].\ActionDataRow(y)\% 2 = 0 \\
%%       \wedge (\neg (t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1) \\
%%       \phantom{\wedge(}\wedge (t_1.\NumRows > 1 \wedge t_1[1].\MatchRow(x_1) = x_1) \\
%%       \phantom{\wedge(}\Rightarrow t_1[1].\ActionDataRow(y) \% 2 = 0 \wedge t_0[1].\ActionDataRow(y)\% 2 = 0 )\\
%%       \wedge ((t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1) \\
%%       \phantom{\wedge (}\vee (t_1.\NumRows ? 1 \wedge t_1[1].\MatchRow(x_1) = x_1)) \\
%%     \end{array} \\
%%     \wedge\,t_0[1].\ActionDataRow(y) \% 3 \neq 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_2.\NumRows > 0 \wedge t_2[0].\MatchRow(x_2) = x_2 \\
%%       \qquad \Rightarrow t_2[0].\ActionDataRow(y) \% 2 = 0 \wedge t_0[1].\ActionDataRow(y)\% 2 = 0 \\
%%       \wedge (\neg (t_2.\NumRows > 0 \wedge t_2[0].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge(}\wedge (t_2.\NumRows > 1 \wedge t_2[1].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge(}\Rightarrow t_2[1].\ActionDataRow(y) \% 2 = 0 \wedge t_0[1].\ActionDataRow(y)\% 2 = 0 )\\
%%       \wedge (\neg (t_2.\NumRows > 0 \wedge t_2[0].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge (}\wedge \neg (t_2.\NumRows ? 1 \wedge t_2[1].\MatchRow(x_2) = x_2) \\
%%       \phantom{\wedge (} t_0[1].\ActionDataRow(y) \% 2 = 0)
%%     \end{array}
%%   \end{array} \\
%%   \neg (t_0.\NumRows > 0 \wedge t_0[0].\MatchRow(x_0) = x_0) \\
%%   \wedge \neg (t_0.\NumRows > 1 \wedge t_0[1].\MatchRow(x_0) = x_0 ) \\
%%   \Rightarrow
%%   \begin{array}[t]{l}
%%     t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1 \\
%%     \qquad \Rightarrow t_1[0].\ActionDataRow(y) \% 2 = 0 \\
%%     \wedge (\neg (t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1) \\
%%     \phantom{\wedge(}\wedge (t_1.\NumRows > 1 \wedge t_1[1].\MatchRow(x_1) = x_1) \\
%%     \phantom{\wedge(}\Rightarrow t_1[1].\ActionDataRow(y) \% 2 = 0 )\\
%%     \wedge ((t_1.\NumRows > 0 \wedge t_1[0].\MatchRow(x_1) = x_1) \\
%%     \phantom{\wedge (}\vee (t_1.\NumRows ? 1 \wedge t_1[1].\MatchRow(x_1) = x_1)) \\
%%     \end{array}
%% \end{array}
%% \]

%% \subsubsection{Question~\ref{question:rowiter}}

%% For this example, its clear that we dont need the cases for both \(t_i[0]\) and
%% \(t_i[1]\) for $i = 1,2,3$, so we can equivalently compute the following
%% (universally closed) verification condition.

%% \[
%% \begin{array}{l}
%%   t_0.\MatchRow(x_0) = x_0 \\
%%   \Rightarrow
%%   \begin{array}[t]{l}
%%     t_0.\ActionDataRow(y) \% 3 = 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_1.\MatchRow(x_1) = x_1 \\
%%       \qquad \Rightarrow t_1.\ActionDataRow(y) \% 2 = 0 \wedge t_0.\ActionDataRow(y)\% 2 = 0 \\
%%       \wedge \neg (t_1.\MatchRow(x_1) = x_1 \Rightarrow \bot) \\
%%     \end{array} \\
%%     \wedge\,t_0.\ActionDataRow(y) \% 3 \neq 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_2.\MatchRow(x_2) = x_2 \\
%%       \qquad \Rightarrow t_2.\ActionDataRow(y) \% 2 = 0 \wedge t_0.\ActionDataRow(y)\% 2 = 0 \\
%%       \wedge (\neg (t_2.\MatchRow(x_2) = x_2) \\
%%       \qquad \Rightarrow t_0.\ActionDataRow(y) \% 2 = 0)
%%     \end{array}
%%   \end{array} \\\\
%%   \wedge \neg (t_0.\MatchRow(x_0) = x_0)
%%   \Rightarrow
%%   \begin{array}[t]{l}
%%     t_1.\MatchRow(x_1) = x_1 \Rightarrow t_1.\ActionDataRow(y) \% 2 = 0 \\
%%     \wedge \, \neg(t_1.\MatchRow(x_1) = x_1 \Rightarrow \bot)\\
%%     \end{array}
%% \end{array}
%% \]
%% which is similar to p4v's approach.

%% \subsubsection{Question~\ref{question:elimination}}

%% Looking at these examples, its not clear that we can eliminate the dataplane
%% state, which occurs only in the form of match conditions. Specifically,
%% dataplane state occurs only in the formula as expressions the form
%% \(t_i.\MatchRow(x_i) = x_i \Rightarrow \varphi\), where \(\varphi\) is some
%% further formula that may intermingle control and dataplane state.

%% Inspecting the formula above, my intuition tells me that we should be able to
%% come up with a rewrite rule that replaces these occurences with \(\top\),
%% resulting in a formula with shape.

%% \[
%% \begin{array}{l}
%%   \begin{array}[t]{l}
%%     t_0.\ActionDataRow(y) \% 3 = 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_1.\ActionDataRow(y) \% 2 = 0 \wedge t_0.\ActionDataRow(y)\% 2 = 0 \\
%%     \end{array} \\
%%     \wedge\,t_0.\ActionDataRow(y) \% 3 \neq 0 \Rightarrow
%%     \begin{array}[t]{l}
%%       t_2.\ActionDataRow(y) \% 2 = 0 \wedge t_0.\ActionDataRow(y)\% 2 = 0 \\
%%     \end{array}
%%   \end{array} \\
%%   \,\,\,\wedge\, t_1.\ActionDataRow(y) \% 2 = 0 \\
%% \end{array}
%% \]

%% which constraints only controllable variables.

%% However, we have completely lost the fact that no packet may miss in table
%% \(t_1\), which is encoded in the raw formula. More care is needed here.


%% \subsection{Existential Example}

%% For a while I've been concerned with the issue of control plane conditions of
%% the form \[\forall \rho_1 \in t_1, \exists \rho_2 \in t_2,\] because I was
%% afraid that this row existence wouldn't be captured in the predicate transformer
%% semantics. This is related to Question~\ref{question:rowiter}---the multiplicity
%% of rows is intended to enable this kind of fine-grained approach.

%% It seems that we \emph{can} recover the existential information from the weakest
%% preconditions constructed from instrumenting with only a single rule.

%% Consider the following program that focuses on a single header instance \texttt{h}.
%% \begin{figure}[H]
%%   \begin{minipage}{0.32\textwidth}
%% \begin{verbatim}
%% control {
%%   out := 0;
%%   h.setInvalid();
%%   t1.apply();
%%   if(h.isValid()){
%%     t2.apply();
%%     assert out!=0;
%%   }
%% }
%% \end{verbatim}
%%   \end{minipage} \begin{minipage}{0.39\textwidth}
%% \begin{verbatim}
%% table t1 {
%%   keys = x : exact;
%%   acts : set_h
%%   default_action : nop
%% }
%% table t2 {
%%   keys = h.f:exact;
%%   acts = {nop; set_out}
%%   default_action = nop;:
%% }
%% \end{verbatim}
%%   \end{minipage} \begin{minipage}{0.27\textwidth}
%% \begin{verbatim}
%% action set_h(f)  {
%%   h.setValid();
%%   h.f := x;
%% }
%% action set_out (o) {
%%   out := o
%% }
%% action nop () {}
%% \end{verbatim}
%% \end{minipage}
%% \end{figure}

%% Notice that the control plane must satisfy the following condtion for the assertion to never fail:
%% \[ \forall \rho_1 \in t_1.~\exists \rho_2 \in t_2.~\rho_2.\MatchRow(h.f) = \rho_1.\ActionDataRow(f) \wedge \rho_2.\ActionDataRow(o) \neq 0 \]

%% If we follow the single-row-per-table instrumentation strategy, we compute the
%% following condition:

%% \[\begin{array}{l}
%% t_1.\MatchRow(x) = x \Rightarrow \\
%% \quad t_2.\MatchRow(h.f) = t_1.\ActionDataRow(f) \\
%% \quad \wedge t_2.\ActionDataRow(o) \neq 0
%% \end{array}\]

%% which bears a striking resemblence to the condition above. We can typset them side-by-side to highlight the similarities.

%% \[\begin{array}{lcl}
%% t_1.\MatchRow(x) = x \Rightarrow && \forall \rho_1 \in t_1. \\
%% \quad t_2.\MatchRow(h.f) = t_1.\ActionDataRow(f) & \leadsto & \quad \exists \rho_2 \in t_2.~\rho_2.\MatchRow(h.f) = \rho_1.\ActionDataRow(f) \\
%% \qquad \wedge t_2.\ActionDataRow(o) \neq 0 && \qquad \wedge\rho_2.\ActionDataRow(o) \neq 0
%% \end{array}
%% \]

%% This provides evidence for the p4v approach, in repsonse to Question~\ref{question:rowiter}.

%% \subsection{Hypothesizing Transformations}

%% In response to Question~\ref{question:eliminations}, we can hypothesize the
%% following transformation rules in response to the above example, where
%% \(t.\mathsf{o}\) represents an arbitrary access to table \(t\), \(\texttt{d}\)
%% represents dataplane state,

%% \[\begin{array}{l>{\leadsto}cr}
%% t.\MatchRow(x) = x \rightarrow \phi && \forall \rho \in t. \phi \\
%% t.\mathsf{o} = t'.\mathsf{o'} \wedge \phi && \exists \rho \in t'. \phi \\
%% t.\mathsf{o} = n && \rho.\mathsf{o} = n \\
%% \end{array}\]

%% An example of each of these can be seen in the example above.

%% However, these rules as stated are incorrect, they must aqcuire and maintain
%% some context. For example, in the final rule, mapping tests liket $t.\mathsf(o)
%% = 0$, we need to know which \(\rho\) row-variable corresponds to the \(t\).

%% Not only that, but we also need to know how to bind the variables. For example,
%% how would we translate a rule like
%% \[t_1.\MatchRow = 6 \Rightarrow t_2.\MatchRow = 7\]

%% The set of hypothesized rules suggests that this should become
%% \[\forall \rho_1 \in t_1. \rho_1.\MatchRow = 6 \Rightarrow \exists \rho_2 \in t_2. \rho_2.\MatchRow = 7\]

%% Some random thoughts
%% \begin{enumerate}
%% \item Context seems important
%% \item Can we generalize this into only introducing one operator? It seems like
%%   both of the quantifier introduction rules could be replaced by a local
%%   \(\exists\)-quantifiaction,
%% \item We need more examples and a more formal approach. Can we derive these rules?
%% \end{enumerate}



%% \subsection{Additional Examples}
%% More examples are needed to investigate
%% Questions~\ref{question:rowiter}\&\ref{question:elimination}.

%% \clearpage
%% \section{(OUTDATED) An Incremental Problem Statement}

%% Writing an instrumentation function for these indexed variables seems difficult.
%% Instead lets just concentrate on a single new insertion at a time into a table
%% $t$. This way, we can simply just insert the instrumented edit
%% \[?\delta_t = \mathsf{Add}(\langle t.\MatchRow(0),\ldots,
%%   t.\MatchRow(n-1)\rangle, t.\ActionRow(t.\ActionDataRow(0), \ldots,
%%   t.\ActionDataRow(m-1)))\] where $n$ is the number of keys in table
%% $t$, and $m$ is the maximum number of action data parameters that any
%% action in $t$ has. For this incremental solution we can omit the
%% subscripts, because there's only one rule being added.

%% \begin{quote}
%%   \it Given a program $p$, a table $t$, and a minimal instantiation
%%   $\sigma$ compute the weakest formula $\varphi$ such that
%%   $\mathit{wp}(p[\sigma;?\delta_t],\top) \Rightarrow \varphi$.
%% \end{quote}

%% \subsection{One Possible Solution}

%% We can write a formula $\psi = \mathit{wp}(p[\sigma;\varphi],\top)$, as
%% \[\forall d_1,\ldots, d_n. \psi[c_1,\ldots,c_n,d_1,\ldots,d_m]\]
%% where the variables $d_i$ are dataplane variables like
%% \texttt{ipv4.src\_addr} and the variables $d_1, \ldots, d_m$ are
%% controllable variables like $t.\MatchRow(j)$, and
%% $\{d_1,\ldots, d_m, c_1,\ldots, c_n\}$ are all the free variables of $\varphi_{\mathit{vc}}$

%% Then, compute a solution $\varphi$ by performing quantifier
%% elimination on the $d_1,\ldots,d_n$.

%% This is probably untenable to do in the brute-force way. Is there another way?

%% \subsection{Failed Horn Encoding}


%% Given the above formula $\psi$, solve following CHC for $H$

%% \[H \leftarrow \forall \vec d.\psi[\vec d, \vec c]\]

%% This will trivially give True.



\end{document}
