open Primitives

(**
  The [Cmd.Make] functor generates IRs for nondeterminitistic code
  based on a set of core primitives defined by the parameter module
  [P], which must have module type [Primitive] defined in [Primitives]. 

  A Cmd [c] can either be: an assumption, an assertion, a sequential composition, 
  a nondeterministic choice, or some primitive action drawn from [P]. 
*)
module Make : functor (P : Primitive) ->
 sig

  (** The type [t] describes the structure of commands.  *)
  type t =
    | Prim of P.t (** [Prim p] for a [p] of type [P.t] constructs a primitive action *)
    | Seq of t list (** [Seq cs] constructs an nary sequential composition *)
    | Choice of t list (** [Choice cs] constructs an n-ary nondeterministic composition*)

  (** [assume b] is a core construct that can be constructed by any instance of [Cmd].
      In the IR semantics, [assume b] is a no-action when [b] evaluates to [true] and
      fails to terminate when [b] evaluates to [false]. 
    *)
  val assume : BExpr.t -> t

  (** [assert_ b] is a core construct that can be constructed by any instance of [Cmd].
    In the IR semantics, [assert_ b] is a no-action when [b] evaluates to [true] and
    crashes the program when [b] evaluates to [false]. 
  *)
  val assert_ : BExpr.t -> t

  (** [skip] is a command that does nothing *)
  val skip : t

  (** [pass] is a command that does nothing*)
  val pass : t

  (** [dead] marks the current execution unreachable
    * it is equivalent to [assume_ BExpr.false_]*)
  val dead : t

  (** [abort] fails the current execution *)
  val abort : t

  (** [prim p] constructs a [Cmd] from a primitive [p]*)
  val prim : P.t -> t

  (** [is_primitive c] returns [true] when [c = Prim p]*)
  val is_primitive : t -> bool

  (** [seq c1 c2] sequentially composes [c1] and [c2] *)
  val seq : t -> t -> t

  (** [sequence cs] constructs the sequential composition, from left-to right, of the elements of [cs]*)
  val sequence : t list -> t

  (** [sequence_opt cs] returns [Some cs'] when every element of [cs] is [Some _], and returns [None] when at least one element of [cs] is [None]*)
  val sequence_opt : t option list -> t option

  (** [sequence_map xs ~f] applies [f] to each element of [xs] and produces the sequential composition of the resulting commands*)
  val sequence_map : 'a list -> f:('a -> t) -> t

  (** [choice c1 c2] produces the nondeterministic choice of both [c1] and [c2].
    * The nondeterministic choice here can be thought of as "demonic" in that
    * if either branch produces an assertion failure, the whole program fails.
    *)
  val choice : t -> t -> t

  (** [choices cs] produces the nondeterministic choice of all of the
    * elements in cs. Since `choice` is commutative, the order of composition
    * is left unspecified *)
  val choices : t list -> t

  (** [choices_map xs] runs [f] on each element of [xs] and constructs a 
    * nondeterministic choice between the resulting commands
  *)
  val choices_map : 'a list -> f:('a -> t) -> t

  (** [choices_opt os] produces the [Some c] when every element of [os] is [Some _]
    * and [c] is their nondeterministic choice. It produces [None], when any
    * element of [os] is [None] 
    *)
  val choices_opt : t option list -> t option

  (** [choice_seq cs cs'] is equivalent to [choice [sequence cs] [sequence cs']]*)
  val choice_seq : t list -> t list -> t
  
  (** [choice_seqs css] is equivalent to [choices_map css ~f:sequence]*)
  val choice_seqs : t list list -> t

  (** [contra c1 c2] is `[true]` when [c1] and [c2] are contradictory*)
  val contra : t -> t -> bool

  (** [to_string c] produces a string representation of [c]*)
  val to_string : t -> string

  (** [size c] produces the size in # of AST nodes of [c]*)
  val size : t -> int

  (** [vars c] produces a list of all of the variables that occur in [c]*)
  val vars : t -> Var.t list
 
  (** The functions that follow are standard. They are generated by PPX deriving *)

  val equal : t -> t -> bool
  val compare : t -> t -> int


  val sexp_of_t : t -> Sexplib.Sexp.t
  val t_of_sexp : Sexplib.Sexp.t -> t

  val quickcheck_generator : t Base_quickcheck.Generator.t
  val quickcheck_observer : t Base_quickcheck.Observer.t
  val quickcheck_shrinker : t Base_quickcheck.Shrinker.t

  val hash_fold_t : t Base__Ppx_hash_lib.hash_fold
  val hash : t -> Base__Ppx_hash_lib.Std.Hash.hash_value
end
